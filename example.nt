<https://github.com/piruty/gihyo-bayesian-filter> <https://schema.org/codeRepository> <https://github.com/piruty/gihyo-bayesian-filter> .
<https://github.com/codemotionamsterdam> <https://schema.org/name> "Codemotion Amsterdam"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> <https://schema.org/dateModified> "2019-01-24T17:50:21"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/qasimwasfi> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/zwlforever> <https://schema.org/image> <https://avatars3.githubusercontent.com/u/8939305?v=4> .
<https://github.com/codemotionamsterdam> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20204892> .
<https://github.com/uluumy> <https://schema.org/contributor> <https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> .
<https://github.com/jorgemachucav> <https://schema.org/identifier> "47221983"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <https://schema.org/dateModified> "2019-02-24T08:27:06"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/Briechenstein12> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/minedor26> <https://schema.org/BookmarkAction> <https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> .
<https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> <https://schema.org/description> " Search documentation... Support Dashboard Card Payments Quickstart Securely collect card information from your customers and create a card payment.  Supported cards Users in the United States can accept Visa Mastercard American Express Discover JCB Diners Club credit and debit cards.  Stripe also supports a range of additional payment methods, depending on the country of your Stripe account.  Accepting a card payment using Stripe is a two-step process, with a client-side and a server-side action:  From your website running in the customer\u2019s browser, Stripe securely collects your customer\u2019s payment information and returns a representative token. This, along with any other form data, is then submitted by the browser to your server. Using the token, your server-side code makes an API request to create a charge and complete the payment. Tokenization ensures that no sensitive card data ever needs to touch your server so your integration can operate in a PCI compliant way.  Step 1: Securely collecting payment information  Checkout reference Complete information about available options and parameters is provided in the Checkout reference.  The simplest way for you to securely collect and tokenize card information is with Checkout. It combines HTML, JavaScript, and CSS to create an embedded payment form. When your customer enters their payment information, the card details are validated and tokenized for your server-side code to use.  To see Checkout in action, click the button below, filling in the resulting form with:  Any random, syntactically valid email address (the more random, the better) One of Stripe\u2019s test card numbers, such as 4242 4242 4242 4242 Any three-digit CVC code Any expiration date in the future To get started, add the following code to your payment page, making sure that the form submits to your own server-side code:  <form action=\"your-server-side-code\" method=\"POST\">   <script     src=\"https://checkout.stripe.com/checkout.js\" class=\"stripe-button\"     data-key=\"pk_test_2DtHIU1N9li5GpmJjyxkQMHh\"     data-amount=\"999\"     data-name=\"Demo Site\"     data-description=\"Example charge\"     data-image=\"https://stripe.com/img/documentation/checkout/marketplace.png\"     data-locale=\"auto\">   </script> </form> We\u2019ve pre-filled the data-key attribute with your test publishable API key\u2014only you can see this value. When you\u2019re ready to go live with your payment form, you must replace the test key with your live key. Learn more about how the keys play into test and live modes.  Although optional, we highly recommend also having Checkout collect the user\u2019s ZIP code, as address and ZIP code verifications help reduce fraud. Add data-zip-code=\"true\" to the above and enable declines on verification failures in your account settings. You can also set Checkout to collect the user\u2019s full billing and shipping addresses (using the corresponding parameters).  Requiring more than the minimum information lowers the possibility of a payment being declined or disputed in the future. Any fraudulent payments that you process are ultimately your responsibility, so requiring a little more than the minimum amount of information is an effective way to combat fraud.  Radar, our modern suite of fraud protection tools, is only available to users who have implemented client-side tokenization. By doing so, it ensures that you can pass the necessary data required for our machine-learning fraud prevention models to make more accurate predictions.  The amount provided in the Checkout form code is only shown to the user. It does not set the amount that the customer will be charged\u2014you must also specify an amount when making a charge request. As you build your integration, make sure that your payment form and server-side code use the same amount to avoid confusion.  An alternative to the blue button demonstrated above is to implement a custom Checkout integration. The custom approach allows you to use any HTML element or JavaScript event to open Checkout, as well as be able to specify dynamic arguments, such as custom amounts.  Stripe.js and Elements If you\u2019d prefer to have complete control over the look and fel of your payment form, you can make use of Stripe.js and Elements, our pre-built UI components. Refer to our Elements quickstart to learn more.  Mobile SDKs Using our native mobile libraries for iOS and Android, Stripe can collect your customer\u2019s payment information from within your mobile app and create a token for your server-side code to use.  Step 2: Creating a charge to complete the payment  Once a token is created, your server-side code makes an API request to create a one-time charge. This request contains the token, currency, amount to charge, and any additional information you may want to pass (e.g., metadata).  curl Ruby Python PHP Java Node Go .NET curl https://api.stripe.com/v1/charges \\    -u sk_test_fyzWf8eDyljIob76fMVSwIsi: \\    -d amount=999 \\    -d currency=usd \\    -d description=\"Example charge\" \\    -d source=tok_6Pk6W3hFiGB7dyNavdvyrFkM These requests expect the ID of the Token (e.g., tok_KPte7942xySKBKyrBu11yEpf) to be provided as the value of the source parameter.  Tokens can only be used once, and within a few minutes of creation. Using this approach, your customers need to re-enter their payment details each time they make a purchase. You can also save card details with Stripe for later use. Using this method, returning customers can quickly make a payment without providing their card details again.  Next steps Congrats! You can now accept card payments with Stripe using Checkout. You may now want to check out these resources:  Creating charges Getting paid Managing your Stripe account Supported payment methods Saving cards Questions? We're always happy to help with code or other questions you might have! Search our documentation, contact support, or connect with our sales team. You can also chat live with other developers in #stripe on freenode.  Was this page helpful? Yes No"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/macosunity> <https://schema.org/BookmarkAction> <https://github.com/SOYJUN/Implement-ODR-protocol> .
<https://github.com/qasimwasfi> <https://schema.org/identifier> "15672665"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/codemotionamsterdam> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/nileshlg2003> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/SOYJUN> <https://schema.org/image> <https://avatars1.githubusercontent.com/u/8823580?v=4> .
<https://github.com/Nemshan> <https://schema.org/name> "Nemshan Alharthi"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> <https://schema.org/dateModified> "2019-01-17T14:23:07"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/minedor26> <https://schema.org/identifier> "42230986"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/kwaikar/ml_marketplace> <https://schema.org/dateModified> "2019-03-13T17:59:44"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/nileshlg2003> <https://schema.org/name> "Nilesh Goswami"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution> <https://schema.org/author> <https://github.com/qasimwasfi> .
<https://github.com/kwaikar/ml_marketplace> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/kakus5> <https://schema.org/identifier> "25538218"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> <https://schema.org/description> "Summary  In this article, we are going to present the solution for the Women\u2019s Health Risk Assessment data science competition on Microsoft\u2019s Cortana Intelligence platform which was ranked among the top 5%. In this page, you can find the published Azure ML Studio experiment., a description of the data science process used, and finally a link to the R code (in GitHub).   Competition Here is the description from the Microsoft Cortana Competition  \u201CTo help achieve the goal of improving women's reproductive health outcomes in underdeveloped regions, this competition calls for optimized machine learning solutions so that a patient can be accurately categorized into different health risk segments and subgroups. Based on the categories that a patient falls in, healthcare providers can offer an appropriate education and training program to patients. Such customized programs have a better chance to help reduce the reproductive health risk of patients. This dataset used in this competition was collected via survey in 2015 as part of a Bill & Melinda Gates Foundation funded project exploring the wants, needs, and behaviors of women and girls with regards to their sexual and reproductive health in nine geographies. The objective of this machine learning competition is to build machine learning models to assign a young woman subject (15-30 years old) in one of the 9 underdeveloped regions into a risk segment, and a subgroup within the segment.\u201D https://gallery.cortanaintelligence.com/Competition/Womens-Health-Risk-Assessment-1  Dataset The contains 9000 observations The original training dataset is in CSV format and can be found in the competition\u2019s description. To submit a solution, two options are possible: build it in Azure ML Studio or build your solutions locally in R and then submit it through Azure ML Studio.  An Azure ML\u2019s solution, and a R script code where given as example. The two solutions are based on the use of a Generalized Linear Model is automatically downloaded.  You can find a detailed description of the dataset, the R sample Code and a tutorial using Azure ML and R in the competition page   Solution I started following the R tutorial for this competition.  Then I have submitted the exact same R solution. The sample model has a 77% accuracy Pre-processing & Cleaning The first thing I did was changing the initial multinomial model (nnet package) for a random forest model (RandomForest package).  All missing values have been replaced by 0 Feature selection Features have been selected using the function varImpPlot from the randomforest package Parameter tuning I have chosen (for educational matter) to use the module Tune Model Hyperparameters in Azure ML Studio. I could have also used the R Package Caret. Evaluation The final model has an accuracy of 86.36% (18 position over almost 500 participants) You can download the R code here"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/codemotionamsterdam> <https://schema.org/contributor> <https://github.com/codemotionamsterdam/codemotionrank> .
<https://github.com/uluumy> <https://schema.org/name> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/codemotionamsterdam/codemotionrank> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/uluumy> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20204892> .
<https://github.com/piruty/gihyo-bayesian-filter> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/uluumy> <https://schema.org/image> <https://avatars2.githubusercontent.com/u/20103069?v=4> .
<https://github.com/macosunity> <https://schema.org/image> <https://avatars2.githubusercontent.com/u/3349399?v=4> .
<https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> <https://schema.org/programmingLanguage> "R"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/macosunity> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/piruty> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20204892> .
<https://github.com/kakus5> <https://schema.org/image> <https://avatars0.githubusercontent.com/u/25538218?v=4> .
<https://github.com/kunal924> <https://schema.org/BookmarkAction> <https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> .
<https://github.com/macosunity> <https://schema.org/identifier> "3349399"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/HowWeLand> <https://schema.org/identifier> "34463960"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/kwaikar> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20204892> .
<https://github.com/kwaikar/ml_marketplace> <https://schema.org/codeRepository> <https://github.com/kwaikar/ml_marketplace> .
<https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> <https://schema.org/dateCreated> "2016-11-01T23:54:14"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/kakus5> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> <https://schema.org/codeRepository> <https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> .
<https://github.com/codemotionamsterdam/codemotionrank> <https://schema.org/dateCreated> "2019-03-05T13:09:16"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/kunal924> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/piruty> <https://schema.org/contributor> <https://github.com/piruty/gihyo-bayesian-filter> .
<https://github.com/Nemshan> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution> <https://schema.org/codeRepository> <https://github.com/qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution> .
<https://github.com/qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution> <https://schema.org/dateCreated> "2018-07-30T08:35:40"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/Briechenstein12> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20204892> .
<https://github.com/piruty/gihyo-bayesian-filter> <https://schema.org/dateCreated> "2016-01-19T07:05:25"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> <https://schema.org/programmingLanguage> "Jupyter Notebook"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/kashenfelter> <https://schema.org/identifier> "32109425"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/kwaikar> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/SOYJUN> <https://schema.org/identifier> "8823580"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/kashenfelter> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/jorgemachucav> <https://schema.org/BookmarkAction> <https://github.com/SOYJUN/Implement-ODR-protocol> .
<https://github.com/piruty> <https://schema.org/image> <https://avatars3.githubusercontent.com/u/8793641?v=4> .
<https://github.com/kwwaikar> <https://schema.org/identifier> "36546813"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/piruty> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/piruty/gihyo-bayesian-filter> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> <https://schema.org/name> "uluumy/Data4People-Women-s-Health-Risk-Assessment"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/HowWeLand> <https://schema.org/BookmarkAction> <https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> .
<https://github.com/SuriyaaKudoIsc> <https://schema.org/name> "Suriyaa \u270C\uFE0F\uFE0F"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/codemotionamsterdam/codemotionrank> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/Briechenstein12> <https://schema.org/contributor> <https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> .
<https://github.com/Briechenstein12> <https://schema.org/identifier> "1453935"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <https://schema.org/author> <https://github.com/SOYJUN> .
<https://github.com/Nemshan> <https://schema.org/identifier> "37916757"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/piruty> <https://schema.org/identifier> "8793641"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/SOYJUN> <https://schema.org/contributor> <https://github.com/SOYJUN/Implement-ODR-protocol> .
<https://github.com/qasimwasfi> <https://schema.org/contributor> <https://github.com/qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution> .
<https://github.com/piruty/gihyo-bayesian-filter> <https://schema.org/author> <https://github.com/piruty> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <https://schema.org/programmingLanguage> "C"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/zwlforever> <https://schema.org/BookmarkAction> <https://github.com/SOYJUN/Implement-ODR-protocol> .
<https://github.com/joeymcc> <https://schema.org/BookmarkAction> <https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> .
<https://github.com/qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution> <https://schema.org/dateModified> "2018-07-30T08:37:57"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/kwaikar/ml_marketplace> <https://schema.org/identifier> "172388731"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/joeymcc> <https://schema.org/identifier> "45340042"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> <https://schema.org/identifier> "5219695"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/Briechenstein12> <https://schema.org/BookmarkAction> <https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> .
<https://github.com/zwlforever> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/codemotionamsterdam/codemotionrank> <https://schema.org/description> "What is CodemotionRank?  CodemotionRank is part of the Codemotion Platform\u2019s online 24/7 experience. CodemotionRank is a place where programmers from all over the world come together to solve problems in a wide range of Computer Science domains such as algorithms, machine learning, or artificial intelligence, as well as to practice different programming paradigms like functional programming.  Our Coding Challenges Cover These Domains Algorithms Artificial Intelligence: Write an AI bot to play a 1-player game, or play against other AI bots! Distributed Systems Databases Mathematics Cryptography and Security Language Specific Domains: Test your coding chops with Java, C++, Ruby, Python, Linux shell, SQL, a variety of functional languages. Don\u2019t see what you\u2019re looking for? We\u2019re adding new domains all the time!  Why should you solve challenges? Learning. Expand your knowledge by learning new programming topics and techniques by going through our challenges and editorial solutions. We believe the best way to learn something is by doing it!  Community. We\u2019re constantly growing community of developers who discuss problems, learn, compete, and collaborate together online and offline.  For Fun. What\u2019s more exciting than solving challenging problems? We\u2019re constantly adding helpful features to make our platform the best possible experience, such as boilerplate code and animations that display when you\u2019re running code.  Jobs. Looking for a job at an awesome company? You can get hired by solving challenges! See our Jobs page for details.  Glory. As you solve more challenges, you earn points and move up the  CodemotionRank Leaderboard.  Sign up below and get started!"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution> <https://schema.org/programmingLanguage> "Python"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/kwwaikar> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/SuriyaaKudoIsc> <https://schema.org/identifier> "5073946"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/jorgemachucav> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/SuriyaaKudoIsc> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> <https://schema.org/codeRepository> <https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <https://schema.org/dateCreated> "2015-04-10T18:49:12"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution> <https://schema.org/identifier> "142848147"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution> <https://schema.org/name> "qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/nileshlg2003> <https://schema.org/image> <https://avatars1.githubusercontent.com/u/4803667?v=4> .
<https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> <https://schema.org/dateModified> "2018-12-01T08:10:35"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/qasimwasfi> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20204892> .
<https://github.com/jorgemachucav> <https://schema.org/image> <https://avatars3.githubusercontent.com/u/47221983?v=4> .
<https://github.com/kwaikar> <https://schema.org/identifier> "15643464"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <https://schema.org/description> "Overview  For this assignment you will be developing and implementing :  An On-Demand shortest-hop Routing (ODR) protocol for networks of fixed but arbitrary and unknown connectivity, using PF_PACKET sockets. The implementation is based on (a simplified version of) the AODV algorithm.  Time client and server applications that send requests and replies to each other across the network using ODR. An API you will implement using Unix domain datagram sockets enables applications to communicate with the ODR mechanism running locally at their nodes. I shall be discussing the assignment in class on Wednesday, October 29, and Monday, November 3.  The following should prove useful reference material for the assignment :  Sections 15.1, 15.2, 15.4 & 15.6, Chapter 15, on Unix domain datagram sockets.  PF_PACKET(7) from the Linux manual pages. You might find these notes made by a past CSE 533 student useful. Also, the following link http://www.pdbuchan.com/rawsock/rawsock.html contains useful code samples that use PF_PACKET sockets (as well as other code samples that use raw IP sockets which you do not need for this assignment, though you will be using these types of sockets for Assignment 4). Charles E. Perkins & Elizabeth M. Royer. \u201CAd-hoc On-Demand Distance Vector Routing.\u201D Proceedings of the 2nd IEEE Workshop on Mobile Computing Systems and Applications, New Orleans, Louisiana, February 1999,  pp. 90 - 100.  The  VMware  environment  minix.cs.stonybrook.edu is a Linux box running VMware. A cluster of ten Linux virtual machines, called vm1 through vm10, on which you can gain access as root and run your code have been created on minix. See VMware Environment Hosts for further details.  VMware instructions  takes you to a page that explains how to use the system. The ten virtual machines have been configured into a small virtual intranet of Ethernet LANs whose topology is (in principle) unknown to you.  There is a course account cse533 on node minix, with home directory /users/cse533. In there, you will find a subdirectory Stevens/unpv13e , exactly as you are used to having on the cs system. You should develop your source code and makefiles for handing in accordingly. You will be  handing in  your source code on the minix node.  Note that you do not need to link against the socket library (-lsocket) in Linux. The same is true for -lnsl and -lresolv. For example, take a look at how the LIBS variable is defined for Solaris, in /home/courses/cse533/Stevens/unpv13e_solaris2.10/Make.defines (on compserv1, say) :  LIBS = ../libunp.a -lresolv -lsocket -lnsl -lpthread  But if you take a look at Make.defines on minix (/users/cse533/Stevens/unpv13e/Make.defines) you will find only:  LIBS = ../libunp.a -lpthread  The nodes vm1 , . . . . . , vm10 are all multihomed :  each has two (or more) interfaces. The interface  \u2018eth0 \u2019  should be completely ignored and is not to be used for this assignment (because it shows all ten nodes as if belonging to the same single Ethernet 192.168.1.0/24, rather than to an intranet composed of several Ethernets).  Note that vm1 , . . . . . , vm10 are virtual machines, not real ones. One implication of this is that you will not be able to find out what their (virtual) IP addresses are by using nslookup and such. To find out these IP addresses, you need to look at the file /etc/hosts on minix. More to the point, invoking gethostbyname for a given vm will return to you only the (primary) IP address associated with the interface eth0 of that vm (which is the interface you will not be using). It will not return to you any other IP address for the node. Similarly, gethostbyaddr will return the vm node name only if you give it the (primary) IP address associated with the interface eth0 for the node. It will return nothing if you give it any other IP address for the node, even though the address is perfectly valid. Because of this, and because it will ease your task to be able to use gethostbyname and gethostbyaddr in a straightforward way, we shall adopt the (primary) IP addresses associated with interfaces eth0 as the \u2018canonical\u2019 IP addresses for the nodes (more on this below).  Time client and server  A time server runs on each of the ten vm machines. The client code should also be available on each vm so that it can be evoked at any of them.  Normally, time clients/servers exchange request/reply messages using the TCP/UDP socket API that, effectively, enables them to receive service (indirectly, via the transport layer) from the local IP mechanism running at their nodes. You are to implement an API using Unix domain sockets to access the local ODR service directly (somewhat similar, in effect, to the way that raw sockets permit an application to access IP directly). Use Unix domain SOCK_DGRAM, rather than SOCK_STREAM, sockets (see Figures 15.5 & 15.6, pp. 418 - 419).  API  You need to implement a msg_send function that will be called by clients/servers to send requests/replies. The parameters of the function consist of : int          giving the socket descriptor for write char*     giving the \u2018canonical\u2019 IP address for the destination node, in presentation format int          giving the destination \u2018port\u2019 number char*     giving message to be sent int flag  if set, force a route rediscovery to the destination node even if a non-\u2018stale\u2019 route already exists (see below) msg_send will format these parameters into a single char sequence which is written to the Unix domain socket that a client/server process creates. The sequence will be read by the local ODR from a Unix domain socket that the ODR process creates for itself.  Recall that the \u2018canonical\u2019 IP address for a vm node is the (primary) IP address associated with the eth0 interface for the node. It is what will be returned to you by a call to gethostbyname.  Similarly, we need a msg_recv function which will do a (blocking) read on the application domain socket and return with : int       giving socket descriptor for read char*  giving message received char*  giving \u2018canonical\u2019 IP address for the source node of message, in presentation format int*     giving source \u2018port\u2019 number This information is written as a single char sequence by the ODR process to the domain socket that it creates for itself. It is read by msg_recv from the domain socket the client/server process creates, decomposed into the three components above, and returned to the caller of msg_recv.  Also see the section below entitled ODR and the API. Client  When a client is evoked at a node, it creates a domain datagram socket. The client should bind its socket to a \u2018temporary\u2019 (i.e., not \u2018well-known\u2019) sun_path name obtained from a call to tmpnam() (cf. line 10, Figure 15.6, p. 419) so that multiple clients may run at the same node.  Note that tmpnam() is actually highly deprecated. You should use the mkstemp() function instead - look up the online man pages on minix (\u2018man mkstemp\u2019) for details.   As you run client code again and again during the development stage, the temporary files created by the calls to tmpnam / mkstemp start to proliferate since these files are not automatically removed when the client code terminates. You need to explicitly remove the file created by the client evocation by issuing a call to unlink() or to remove() in your client code just before the client code exits. See the online man pages on minix (\u2018man unlink\u2019, \u2018man remove\u2019) for details. The client then enters an infinite loop repeating the steps below. The client prompts the user to choose one of vm1 , . . . . . , vm10 as a server node.  Client msg_sends a 1 or 2 byte message to server and prints out on stdout the message      client at node  vm i1  sending request to server at  vm i2 (In general, throughout this assignment, \u201Ctrace\u201D messages such as the one above should give the vm names and not IP addresses of the nodes.)  Client then blocks in msg_recv awaiting response. This attempt to read from the domain socket should be backed up by a timeout in case no response ever comes. I leave it up to you whether you \u2018wrap\u2019 the call to msg_recv in a timeout, or you implement the timeout inside msg_recv itself. When the client receives a response it prints out on stdout the message      client at node  vm i1 : received from   vm i2  <timestamp> If, on the other hand, the client times out, it should print out the message      client at node  vm i1 : timeout on response from   vm i2 The client then retransmits the message out, setting the flag parameter in msg_send to force a route rediscovery, and prints out an appropriate message on stdout. This is done only once, when a timeout for a given message to the server occurs for the first time.  Client repeats steps 1. - 3. Server  The server creates a domain datagram socket. The server socket is assumed to have a (node-local) \u2018well-known\u2019 sun_path name which it binds to. This \u2018well-known\u2019 sun_path name is designated by a (network-wide) \u2018well-known\u2019 \u2018port\u2019 value. The time client uses this \u2018port\u2019 value to communicate with the server.  The server enters an infinite sequence of calls to msg_recv followed by msg_send, awaiting client requests and responding to them. When it responds to a client request, it prints out on stdout the message                server at node  vm i1  responding to request from  vm i2 ODR  The ODR process runs on each of the ten vm machines. It is evoked with a single command line argument which gives a \u201Cstaleness\u201D time parameter, in seconds.  It uses get_hw_addrs (available to you on minix in ~cse533/Asgn3_code) to obtain the index, and associated (unicast) IP and Ethernet addresses for each of the node\u2019s interfaces, except for the eth0 and lo (loopback) interfaces, which should be ignored. In the subdirectory ~cse533/Asgn3_code (/users/cse533/Asgn3_code) on minix I am providing you with two functions, get_hw_addrs and prhwaddrs. These are analogous to the get_ifi_info_plus and prifinfo_plus of Assignment 2. Like get_ifi_info_plus, get_hw_addrs uses ioctl. get_hw_addrs gets the (primary) IP address, alias IP addresses (if any), HW address, and interface name and index value for each of the node's interfaces (including the loopback interface lo). prhwaddrs prints that information out. You should modify and use these functions as needed.  Note that if an interface has no HW address associated with it (this is, typically, the case for the loopback interface lo for example), then ioctl returns get_hw_addrs a HW address which is the equivalent of 00:00:00:00:00:00 .  get_hw_addrs stores this in the appropriate field of its data structures as it would with any HW address returned by ioctl, but when prhwaddrs comes across such an address, it prints a blank line instead of its usual \u2018HWaddr = xx:xx:xx:xx:xx:xx\u2019. The ODR process creates one or more PF_PACKET sockets. You will need to try out PF_PACKET sockets for yourselves and familiarize yourselves with how they behave. If, when you read from the socket and provide a sockaddr_ll structure, the kernel returns to you the index of the interface on which the incoming frame was received, then one socket will be enough. Otherwise, somewhat in the manner of Assignment 2, you shall have to create a PF_PACKET socket for every interface of interest (which are all the interfaces of the node, excluding interfaces lo and eth0 ), and bind a socket to each interface. Furthermore, if the kernel also returns to you the source Ethernet address of the frame in the sockaddr_ll structure, then you can make do with SOCK_DGRAM type PF_PACKET sockets; otherwise you shall have to use SOCK_RAW type sockets (although I would prefer you to use SOCK_RAW type sockets anyway, even if it turns out you can make do with SOCK_DGRAM type).  The socket(s) should have a protocol value (no larger than 0xffff so that it fits in two bytes; this value is given as a network-byte-order parameter in the call(s) to function socket) that identifies your ODR protocol. The <linux/if_ether.h> include file (i.e., the file /usr/include/linux/if_ether.h) contains protocol values defined for the standard protocols typically found on an Ethernet LAN, as well as other values such as ETH_P_ALL. You should set protocol to a value of your choice which is not a <linux/if_ether.h> value, but which is, hopefully, unique to yourself. Remember that you will all be running your code using the same root account on the vm1 , . . . . . , vm10 nodes. So if two of you happen to choose the same protocol value and happen to be running on the same vm node at the same time, your applications will receive each other\u2019s frames. For that reason, try to choose a protocol value for the socket(s) that is likely to be unique to yourself (something based on your Stony Brook student ID number, for example). This value effectively becomes the protocol value for your implementation of ODR, as opposed to some other cse 533 student's implementation. Because your value of protocol is to be carried in the frame type field of the Ethernet frame header, the value chosen should be not less than 1536 (0x600) so that it is not misinterpreted as the length of an Ethernet 802.3 frame.  Note from the man pages for packet(7) that frames are passed to and from the socket without any processing in the frame content by the device driver on the other side of the socket, except for calculating and tagging on the 4-byte CRC trailer for outgoing frames, and stripping that trailer before delivering incoming frames to the socket. Nevertheless, if you write a frame that is less than 60 bytes, the necessary padding is automatically added by the device driver so that the frame that is actually transmitted out is the minimum Ethernet size of 64 bytes. When reading from the socket, however, any such padding that was introduced into a short frame at the sending node to bring it up to the minimum frame size is not stripped off - it is included in what you receive from the socket (thus, the minimum number of bytes you receive should never be less than 60). Also, you will have to build the frame header for outgoing frames yourselves (assuming you use SOCK_RAW type sockets). Bear in mind that the field values in that header have to be in network order. The ODR process also creates a domain datagram socket for communication with application processes at the node, and binds the socket to a \u2018well known\u2019 sun_path name for the ODR service.  Because it is dealing with fixed topologies, ODR is, by and large, considerably simpler than AODV. In particular, discovered routes are relatively stable and there is no need for all the paraphernalia that goes with the possibility of routes changing (such as maintenance of active nodes in the routing tables and timeout mechanisms; timeouts on reverse links; lifetime field in the RREP messages; etc.)  Nor will we be implementing source_sequence_#s (in the RREQ messages), and dest_sequence_# (in RREQ and RREP messages). In reality, we should (though we will not, for the sake of simplicity, be doing so) implement some sort of sequence number mechanism, or some alternative mechanism such as split-horizon for example, if we are to avoid possible scenarios of routing loops in a \u201Ccount to infinity\u201D context (I shall explain this point in class).  However, we want ODR to discover shortest-hop paths, and we want it to do so in a reasonably efficient manner. This necessitates having one or two aspects of its operations work in a different, possibly slightly more complicated, way than AODV does. ODR has several basic responsibilities :  Build and maintain a routing table. For each destination in the table, the routing table structure should include, at a minimum, the next-hop node (in the form of the Ethernet address for that node) and outgoing interface index, the number of hops to the destination, and a timestamp of when the the routing table entry was made or last \u201Creconfirmed\u201D / updated. Note that a destination node in the table is to be identified only by its \u2018canonical\u2019 IP address, and not by any other IP addresses the node has.  Generate a RREQ in response to a time client calling msg_send for a destination for which ODR has no route (or for which a route exists, but msg_send has the flag parameter set or the route has gone \u2018stale\u2019 \u2013 see below), and \u2018flood\u2019 the RREQ out on all the node\u2019s interfaces (except for the interface it came in on and, of course, the interfaces eth0 and lo). Flooding is done using an Ethernet broadcast destination address (0xff:ff:ff:ff:ff:ff) in the outgoing frame header.   Note that a copy of the broadcast packet is supposed to / might be looped back to the node that sends it (see p. 535 in the Stevens textbook). ODR will have to take care not to treat these copies as new incoming RREQs.   Also note that ODR at the client node increments the broadcast_id every time it issues a new RREQ for any destination node. When a RREQ is received, ODR has to generate a RREP if it is at the destination node, or if it is at an intermediate node that happens to have a route (which is not \u2018stale\u2019 \u2013 see below) to the destination. Otherwise, it must propagate the RREQ by flooding it out on all the node\u2019s interfaces (except the interface the RREQ arrived on). Note that as it processes received RREQs, ODR should enter the \u2018reverse\u2019 route back to the source node into its routing table, or update an existing entry back to the source node if the RREQ received shows a shorter-hop route, or a route with the same number of hops but going through a different neighbour. The timestamp associated with the table entry should be updated whenever an existing route is either \u201Creconfirmed\u201D or updated. Obviously, if the node is going to generate a RREP, updating an existing entry back to the source node with a more efficient route, or a same-hops route using a different neighbour, should be done before the RREP is generated.  Unlike AODV, when an intermediate node receives a RREQ for which it generates a RREP, it should nevertheless continue to flood the RREQ it received if the RREQ pertains to a source node whose existence it has heretofore been unaware of, or the RREQ gives it a more efficient route than it knew of back to the source node (the reason for continuing to flood the RREQ is so that other nodes in the intranet also become aware of the existence of the source node or of the potentially more optimal reverse route to it, and update their tables accordingly). However, since an RREP for this RREQ is being sent by our node, we do not want other nodes who receive the RREQ propagated by our node, and who might be in a position to do so, to also send RREPs. So we need to introduce a field in the RREQ message, not present in the AODV specifications, which acts like a \u201CRREP already sent\u201D field. Our node sets this field before further propagating the RREQ and nodes receiving an RREQ with this field set do not send RREPs in response, even if they are in a position to do so.  ODR may, of course, receive multiple, distinct instances of the same RREQ (the combination of source_addr and broadcast_id uniquely identifies the RREQ). Such RREQs should not be flooded out unless they have a lower hop count than instances of that RREQ that had previously been received.  By the same token, if ODR is in a position to send out a RREP, and has already done so for this, now repeating, RREQ ,  it should not send out another RREP unless the RREQ shows a more efficient, previously unknown, reverse route back to the source node. In other words, ODR should not generate essentially duplicative RREPs, nor generate RREPs to instances of RREQs that reflect reverse routes to the source that are not more efficient than what we already have. Relay RREPs received back to the source node (this is done using the \u2018reverse\u2019 route entered into the routing table when the corresponding RREQ was processed). At the same time, a \u2018forward\u2019 path to the destination is entered into the routing table. ODR could receive multiple, distinct RREPs for the same RREQ. The \u2018forward\u2019 route entered in the routing table should be updated to reflect the shortest-hop route to the destination, and RREPs reflecting suboptimal routes should not be relayed back to the source. In general, maintaining a route and its associated timestamp in the table in response to RREPs received is done in the same manner described above for RREQs.  Forward time client/server messages along the next hop. (The following is important \u2013 you will lose points if you do not implement it.) Note that such application payload messages (especially if they are the initial request from the client to the server, rather than the server response back to the client) can be like \u201Cfree\u201D RREPs, enabling nodes along the path from source (client) to destination (server) node to build a reverse path back to the client node whose existence they were heretofore unaware of (or, possibly, to update an existing route with a more optimal one). Before it forwards an application payload message along the next hop, ODR at an intermediate node (and also at the final destination node) should use the message to update its routing table in this way. Thus, calls to msg_send by time servers should never cause ODR at the server node to initiate RREQs, since the receipt of a time client request implies that a route back to the client node should now exist in the routing table. The only exception to this is if the server node has a staleness parameter of zero (see below). A routing table entry has associated with it a timestamp that gives the time the entry was made into the table. When a client at a node calls msg_send, and if an entry for the destination node already exists in the routing table, ODR first checks that the routing information is not \u2018stale\u2019. A stale routing table entry is one that is older than the value defined by the staleness parameter given as a command line argument to the ODR process when it is executed. ODR deletes stale entries (as well as non-stale entries when the flag parameter in msg_send is set) and initiates a route rediscovery by issuing a RREQ for the destination node. This will force periodic updating of the routing tables to take care of failed nodes along the current path, Ethernet addresses that might have changed, and so on. Similarly, as RREQs propagate through the intranet, existing stale table entries at intermediate nodes are deleted and new route discoveries propagated. As noted above when discussing the processing of RREQs and RREPs, the associated timestamp for an existing table entry is updated in response to having the route either \u201Creconfirmed\u201D or updated (this applies to both reverse routes, by virtue of RREQs received, and to forward routes, by virtue of RREPs). Finally, note that a staleness parameter of 0 essentially indicates that the discovered route will be used only once, when first discovered, and then discarded. Effectively, an ODR with staleness parameter 0 maintains no real routing table at all ;  instead, it forces route discoveries at every step of its operation. As a practical matter, ODR should be run with staleness parameter values that are considerably larger than the longest RTT on the intranet, otherwise performance will degrade considerably (and collapse entirely as the parameter values approach 0). Nevertheless, for robustness, we need to implement a mechanism by which an intermediate node that receives a RREP or application payload message for forwarding and finds that its relevant routing table entry has since gone stale, can intiate a RREQ to rediscover the route it needs.  RREQ, RREP, and time client/server request/response messages will all have to be carried as encapsulated ODR protocol messages that form the data payload of Ethernet frames. So we need to design the structure of ODR protocol messages. The format should contain a type field (0 for RREQ, 1 for RREP, 2 for application payload ). The remaining fields in an ODR message will depend on what type it is. The fields needed for (our simplified versions of AODV\u2019s) RREQ and RREP should be fairly clear to you, but keep in mind that you need to introduce two extra fields:  The \u201CRREP already sent\u201D bit or field in RREQ messages, as mentioned above.  A \u201Cforced discovery\u201D bit or field in both RREQ and RREP messages:  When a client application forces route rediscovery, this bit should be set in the RREQ issued by the client node ODR.  Intermediate nodes that are not the destination node but which do have a route to the destination node should not respond with RREPs to an RREQ which has the forced discovery field set. Instead, they should continue to flood the RREQ so that it eventually reaches the destination node which will then respond with an RREP.  The intermediate nodes relaying such an RREQ must update their \u2018reverse\u2019 route back to the source node accordingly, even if the new route is less efficient (i.e., has more hops) than the one they currently have in their routing table.  The destination node responds to the RREQ with an RREP in which this field is also set.  Intermediate nodes that receive such a forced discovery RREP must update their \u2018forward\u2019 route to the destination node accordingly, even if the new route is less efficient (i.e., has more hops) than the one they currently have in their routing table.  This behaviour will cause a forced discovery RREQ to be responded to only by the destination node itself and not any other node, and will cause intermediate nodes to update their routing tables to both source and destination nodes in accordance with the latest routing information received, to cover the possibility that older routes are no longer valid because nodes and/or links along their paths have gone down. A type 2, application payload, message needs to contain the following type of information :  type  =  2 \u2018canonical\u2019 IP address of source node \u2018port\u2019 number of source application process (This, of course, is not a real port number in the TCP/UDP sense, but simply a value that ODR at the source node uses to designate the sun_path name for the source application\u2019s domain socket.) \u2018canonical\u2019 IP address of destination node \u2018port\u2019 number of destination application process (This is passed to ODR by the application process at the source node when it calls msg_send. Its designates the sun_path name for an application\u2019s domain socket at the destination node.) hop count (This starts at 0 and is incremented by 1 at each hop so that ODR can make use of the message to update its routing table, as discussed above.) number of bytes in application message The fields above essentially constitute a \u2018header\u2019 for the ODR message. Note that fields which you choose to have carry numeric values (rather than ascii characters, for example) must be in network byte order. ODR-defined numeric-valued fields in type 0, RREQ, and type 1, RREP, messages must, of course, also be in network byte order.  Also note that only the \u2018canonical\u2019 IP addresses are used for the source and destination nodes in the ODR header. The same has to be true in the headers for type 0, RREQ, and type 1, RREP, messages. The general rule is that ODR messages only carry \u2018canonical\u2019 IP node addresses.  The last field in the type 2 ODR message is essentially the data payload of the message.  application message given in the call to msg_send An ODR protocol message is encapsulated as the data payload of an Ethernet frame whose header it fills in as follows :  source address  =  Ethernet address of outgoing interface of the current node where ODR is processing the message. destination address  =  Ethernet broadcast address for type 0 messages; Ethernet address of next hop node for type 1 & 2 messages. protocol field  =  protocol value for the ODR PF_PACKET socket(s). Last but not least, whenever ODR writes an Ethernet frame out through its socket, it prints out on stdout the message      ODR at node  vm i1 : sending      frame  hdr    src  vm i1      dest  addr                                                       ODR msg      type n     src  vm i2      dest  vm i3 where addr is in presentation format (i.e., hexadecimal xx:xx:xx:xx:xx:xx) and gives the destination Ethernet address in the outgoing frame header. Other nodes in the message should be identified by their vm name. A message should be printed out for each packet sent out on a distinct interface.  ODR and the API  When the ODR process first starts, it must construct a table in which it enters all well-known \u2018port\u2019 numbers and their corresponding sun_path names. These will constitute permanent entries in the table.  Thereafter, whenever it reads a message off its domain socket, it must obtain the sun_path name for the peer process socket and check whether that name is entered in the table. If not, it must select an \u2018ephemeral\u2019 \u2018port\u2019 value by which to designate the peer sun_path name and enter the pair  < port value , sun_path name >  into the table. Such entries cannot be permanent otherwise the table will grow unboundedly in time, with entries surviving for ever, beyond the peer processes\u2019 demise. We must associate a time_to_live field with a non-permanent table entry, and purge the entry if nothing is heard from the peer for that amount of time. Every time a peer process for which a non-permanent table entry exists communicates with ODR, its time_to_live value should be reinitialized.  Note that when ODR writes to a peer, it is possible for the write to fail because the peer does not exist :  it could be a \u2018well-known\u2019 service that is not running, or we could be in the interval between a process with a non-permanent table entry terminating and the expiration of its time_to_live value. Notes  A proper implementation of ODR would probably require that RREQ and RREP messages be backed up by some kind of timeout and retransmission mechanism since the network transmission environment is not reliable. This would considerably complicate the implementation (because at any given moment, a node could have multiple RREQs that it has flooded out, but for which it has still not received RREPs; the situation is further complicated by the fact that not all intermediate nodes receiving and relaying RREQs necessarily lie on a path to the destination, and therefore should expect to receive RREPs), and, learning-wise, would not add much to the experience you should have gained from Assignment 2."^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> <https://schema.org/identifier> "128251994"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/codemotionamsterdam> <https://schema.org/image> <https://avatars2.githubusercontent.com/u/38037497?v=4> .
<https://github.com/kwaikar/ml_marketplace> <https://schema.org/description> "My personal collection of sample notebooks that leverage products from AWS Marketplace for machine learning . Link - https://aws.amazon.com/marketplace/search/results?page=1&filters=fulfillment_options&fulfillment_options=SAGEMAKER&searchTerms="^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/kakus5> <https://schema.org/BookmarkAction> <https://github.com/SOYJUN/Implement-ODR-protocol> .
<https://github.com/HowWeLand> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <https://schema.org/identifier> "33745048"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/Briechenstein12> <https://schema.org/name> "Saturnrem Android Blockchain"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> <https://schema.org/name> "Nemshan/predicting-Paid-amount-for-Claims-Data"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/kashenfelter> <https://schema.org/BookmarkAction> <https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> .
<https://github.com/uluumy> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/kwwaikar> <https://schema.org/image> <https://avatars2.githubusercontent.com/u/36546813?v=4> .
<https://github.com/codemotionamsterdam/codemotionrank> <https://schema.org/author> <https://github.com/codemotionamsterdam> .
<https://github.com/SOYJUN> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20204892> .
<https://github.com/piruty/gihyo-bayesian-filter> <https://schema.org/description> "gihyo.jp  \u300C\u6A5F\u68B0\u5B66\u7FD2 \u306F\u3058\u3081\u3088\u3046 \u00BB \u7B2C3\u56DE\u3000\u30D9\u30A4\u30B8\u30A2\u30F3\u30D5\u30A3\u30EB\u30BF\u3092\u5B9F\u88C5\u3057\u3066\u307F\u3088\u3046(http://gihyo.jp/dev/serial/01/machine-learning/0003?page=1)\u300D\u306E\u5199\u7D4C"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/kwaikar> <https://schema.org/image> <https://avatars3.githubusercontent.com/u/15643464?v=4> .
<https://github.com/kwaikar/ml_marketplace> <https://schema.org/dateCreated> "2019-02-24T20:50:23"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/kwaikar> <https://schema.org/name> "Kanchan"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> <https://schema.org/author> <https://github.com/uluumy> .
<https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution> <https://schema.org/description> "Our bot has crawled several product pages from the popular Indian e-commerce website, Flipkart.com. All of these pages are specifically about the most popular books being sold on Flipkart (at the time of the crawl).  Each page contained information for exactly one book. We noted down exactly two fields from each of these pages:  1. The name of the book. 2. Description fragment: The first few sentences of the description of the book, as displayed on the page. In some cases,  this string or text field might be terminated prematurely (i.e., not exactly at a word or a sentence boundary). Each of these text blocks is split into two parts of roughly equal length.  Set A contains the names of all the books. Set B contains the description fragments for all the books.  Both the Sets A and B are shuffled up, and the ordering of elements is lost.  Your task is to identify, for each name (a) in Set A, which is the correct corresponding text fragment (b) in Set B, such that, b was the descriptive fragment for the book named a.  Hints: Getting started - Think about using TF-IDF Scores (or a modification of it)  For those getting started with this fascinating domain of text classification, here's a wonderful Youtube video of Professor Christopher Manning from Stanford, explaining the TF-IDF , which you could consider using as a starting point.   Input Format  An Integer N on the first line. This is followed by 2N+1 lines.  Text fragments (numbered 1 to N) from Set A, each on a new line (so a total of N lines).  A separator with five asterisk marks \"*\" which indicates the end of Set A and the start of Set B.  Text fragments (numbered 1 to N) from Set B, each on a new line (so a total of N lines).  Output Format  N lines, each containing one integer.  The i-th line should contain an integer j such that the j-th element of Set A and the i-th element of Set B are a pair, i.e., both originally came from the same listing page on Flipkart.  Constraints  1 <= N <= 1000  No text fragment will have more than 10000 characters.  Sample Input  5 How to Be a Domestic Goddess : Baking and the Art of Comfort Cooking (Paperback) Embedded / Real-Time Systems 1st Edition (Paperback) The Merchant of Venice (Paperback) Lose a Kilo a Week (Paperback) Few Things Left Unsaid (Paperback) ***** Today the embedded systems are ubiquitous in occurrence, most significant in function and project an absolutely promising picture of developments in the near future. The Merchant Of Venice is one of Shakespeare's best known plays. How To Be A Domestic Goddess: Baking and the Art of Comfort Cooking is a bestselling cookbook by the famous chef Nigella Lawson who aims to introduce the art of baking through text with an emphasis. Lose A Kilo A Week is a detailed diet and weight loss plan, and also shows how to maintain the ideal weight after reaching it. Few Things Left Unsaid is a story of love, romance, and heartbreak. Sample Output  2 3 1 4 5 Explanation  Explaining the Input  The first line indicates that the test case contains the names and descriptions of five popular books listed on Flipkart.  The next five lines are the names of the books (i.e, Set A). After that, we have a separator. That is followed by five lines, each containing description fragments from Set B.  Explaining how we arrived at the Output  The first description, is visibly most closely related to the second book (Embedded / Real-Time Systems 1st Edition (Paperback)).  The second description, is clearly about the Merchant of Venice - which is the third book name in Set-A.  The third description is about Baking - and so, it corresponds to the first of the book names, in Set-A. Similarly, the fourth and fifth descriptions match best with the fourth and fifth book names (i.e, it so happens that they are already in order).  So, the expected output is 2, 3, 1, 4, 5 respectively.  Scoring  The weight for a test case will be proportional to the number of tests (book names) it contains. Two sample tests are available and visible on Compile & Test. A training driven approach or solution is not expected in this challenge, which is why no comprehensive training data has been provided.  Score = M * (C)/N Where M is the Maximum Score for the test case.  C = Number of correct answers in your output.  N = Total number of book names in the test set (which were divided into Set A and Set B respectively).  Note: Submissions will be disqualified if it is evident that the code has been written in such a way that the sample test case answers are hard-coded, or similar approaches, where the answer is not computed, but arrived at by trying to ensure the code matches the sample answers.  Timelimits  Timelimits can be seen here.  Libraries  Libraries available in our Machine Learning/Real Data challenges will be enabled for this contest and are listed here. Please note, that occasionally, a few functions or modules might not work in the constraints of our infrastructure. For instance, some modules try to run multiple threads (and fail). So please try importing the library and functions and cross checking if they work in our online editor in case you plan to develop a solution locally, and then upload to our site."^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <https://schema.org/codeRepository> <https://github.com/SOYJUN/Implement-ODR-protocol> .
<https://github.com/kunal924> <https://schema.org/image> <https://avatars0.githubusercontent.com/u/46965735?v=4> .
<https://github.com/kwaikar/ml_marketplace> <https://schema.org/name> "kwaikar/ml_marketplace"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/codemotionamsterdam/codemotionrank> <https://schema.org/identifier> "173948532"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/codemotionamsterdam/codemotionrank> <https://schema.org/dateModified> "2019-03-05T13:10:28"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/Nemshan> <https://schema.org/contributor> <https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> .
<https://github.com/SOYJUN> <https://schema.org/name> "JUN ZENG"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/piruty/gihyo-bayesian-filter> <https://schema.org/name> "piruty/gihyo-bayesian-filter"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/kwaikar/ml_marketplace> <https://schema.org/author> <https://github.com/kwaikar> .
<https://github.com/codemotionamsterdam> <https://schema.org/identifier> "38037497"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/macosunity> <https://schema.org/name> "\u68A6\u60F3\u5C31\u662F\u505A\u4E2A\u666E\u901A\u4EBA"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/kwwaikar> <https://schema.org/contributor> <https://github.com/kwaikar/ml_marketplace> .
<https://github.com/jorgemachucav> <https://schema.org/name> "JMV"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/piruty> <https://schema.org/name> "piruty"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SuriyaaKudoIsc> <https://schema.org/image> <https://avatars2.githubusercontent.com/u/5073946?v=4> .
<https://github.com/Briechenstein12> <https://schema.org/image> <https://avatars0.githubusercontent.com/u/1453935?v=4> .
<https://github.com/zwlforever> <https://schema.org/identifier> "8939305"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/codemotionamsterdam/codemotionrank> <https://schema.org/codeRepository> <https://github.com/codemotionamsterdam/codemotionrank> .
<https://github.com/Nemshan> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20204892> .
<https://github.com/Nemshan> <https://schema.org/image> <https://avatars0.githubusercontent.com/u/37916757?v=4> .
<https://github.com/HowWeLand> <https://schema.org/image> <https://avatars3.githubusercontent.com/u/34463960?v=4> .
<https://github.com/kwaikar/ml_marketplace> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/kwwaikar> <https://schema.org/name> "Kanchan Waikar"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> <https://schema.org/identifier> "72586985"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/kashenfelter> <https://schema.org/name> "Kathy Targowski Ashenfelter"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/minedor26> <https://schema.org/image> <https://avatars0.githubusercontent.com/u/42230986?v=4> .
<https://github.com/SuriyaaKudoIsc> <https://schema.org/BookmarkAction> <https://github.com/SOYJUN/Implement-ODR-protocol> .
<https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/kwwaikar> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20204892> .
<https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> <https://schema.org/dateCreated> "2018-04-05T19:05:50"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/uluumy> <https://schema.org/identifier> "20103069"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> <https://schema.org/codeRepository> <https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> .
<https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> <https://schema.org/dateCreated> "2012-07-29T03:17:52"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/kashenfelter> <https://schema.org/image> <https://avatars0.githubusercontent.com/u/32109425?v=4> .
<https://github.com/piruty/gihyo-bayesian-filter> <https://schema.org/dateModified> "2016-01-19T07:07:31"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/codemotionamsterdam/codemotionrank> <https://schema.org/name> "codemotionamsterdam/codemotionrank"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/joeymcc> <https://schema.org/image> <https://avatars0.githubusercontent.com/u/45340042?v=4> .
<https://github.com/kunal924> <https://schema.org/identifier> "46965735"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/piruty/gihyo-bayesian-filter> <https://schema.org/programmingLanguage> "Python"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/piruty/gihyo-bayesian-filter> <https://schema.org/identifier> "49933497"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <https://schema.org/name> "SOYJUN/Implement-ODR-protocol"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/nileshlg2003> <https://schema.org/identifier> "4803667"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/nileshlg2003> <https://schema.org/BookmarkAction> <https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> .
<https://github.com/joeymcc> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/SOYJUN> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/kwaikar> <https://schema.org/contributor> <https://github.com/kwaikar/ml_marketplace> .
<https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> <https://schema.org/description> "Introduction The context is the 2016 public use NH medical claims files obtained from NH CHIS (Comprehensive Health Care Information System). The dataset contains Commercial Insurance claims, and a small fraction of Medicaid and Medicare payments for dually eligible people. The primary purpose of this assignment is to test machine learning (ML) skills in a real case analysis setting. You are expected to clean and process data and then apply various ML techniques like Linear and no linear models like regularized regression, MARS, and Partitioning methods. You are expected to use at least two of R, Python and JMP software.  Data details:  Medical claims file for 2016 contains ~17 millions rows and ~60 columns of data, containing ~6.5 million individual medical claims. These claims are all commercial claims that were filed by healthcare providers in 2016 in the state of NH. These claims were ~88% for residents of NH and the remaining for out of state visitors who sought care in NH. Each claim consists of one or more line items, each indicating a procedure done during the doctor\u2019s visit. Two columns indicating Billed amount and the Paid amount for the care provided, are of primary interest. The main objective is to predict \u201CPaid amount per procedure\u201D by mapping a plethora of features available in the dataset. It is also an expectation that you would create new features using the existing ones or external data sources.  Objectives: Step 1: Take a random sample of 1 million unique claims, such that all line items related to each claim are included in the sample. This will result in a little less than 3 million rows of data.  Step 2: Clean up the data, understand the distributions, and create new features if necessary.  Step 3: Run predictive models using validation method of your choice.  Step 4: Write a descriptive report (less than 10 pages) describing the process and your findings. "^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/qasimwasfi> <https://schema.org/image> <https://avatars1.githubusercontent.com/u/15672665?v=4> .
<https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> <https://schema.org/author> <https://github.com/Briechenstein12> .
<https://github.com/kwaikar/ml_marketplace> <https://schema.org/programmingLanguage> "Jupyter Notebook"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> <https://schema.org/author> <https://github.com/Nemshan> .
<https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> <https://schema.org/name> "Briechenstein12/Jerusalem2020j2IL-Repository"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/minedor26> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/qasimwasfi> <https://schema.org/name> "Muhammad Afzal"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> <https://schema.org/identifier> "72586985"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/Nemshan> <https://schema.org/author> <https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> .
<https://github.com/qasimwasfi> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/piruty/gihyo-bayesian-filter> <https://schema.org/codeRepository> <https://github.com/piruty/gihyo-bayesian-filter> .
<https://github.com/kwwaikar> <https://schema.org/image> <https://avatars2.githubusercontent.com/u/36546813?v=4> .
<https://github.com/Nemshan> <https://www.wikidata.org/wiki/Property:P3919> <https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> .
<https://github.com/codemotionamsterdam/codemotionrank> <https://schema.org/dateCreated> "2019-03-05T13:09:16"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/uluumy> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> <https://schema.org/dateModified> "2019-03-26T00:42:31"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/Briechenstein12> <https://schema.org/BookmarkAction> <https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> .
<https://github.com/codemotionamsterdam> <https://schema.org/contributor> <https://github.com/codemotionamsterdam/codemotionrank> .
<https://github.com/piruty> <https://schema.org/identifier> "8793641"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/piruty> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20204892> .
<https://github.com/kashenfelter> <https://schema.org/identifier> "32109425"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/SOYJUN> <https://schema.org/identifier> "8823580"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/Briechenstein12> <https://schema.org/image> <https://avatars0.githubusercontent.com/u/1453935?v=4> .
<https://github.com/jorgemachucav> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/Briechenstein12> <https://schema.org/contributor> <https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> .
<https://github.com/kwaikar/ml_marketplace> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q55630549> .
<https://github.com/zwlforever> <https://schema.org/BookmarkAction> <https://github.com/SOYJUN/Implement-ODR-protocol> .
<https://github.com/qasimwasfi> <https://schema.org/author> <https://github.com/qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/joeymcc> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/codemotionamsterdam> <https://schema.org/author> <https://github.com/codemotionamsterdam/codemotionrank> .
<https://github.com/nileshlg2003> <https://schema.org/name> "Nilesh Goswami"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/macosunity> <https://schema.org/name> "\u68A6\u60F3\u505A\u4E2A\u666E\u901A\u4EBA"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution> <https://schema.org/dateCreated> "2018-07-30T08:35:40"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/codemotionamsterdam/codemotionrank> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/codemotionamsterdam/codemotionrank> <https://schema.org/identifier> "173948532"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <https://schema.org/codeRepository> <https://github.com/SOYJUN/Implement-ODR-protocol> .
<https://github.com/SOYJUN> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/Nemshan> <https://schema.org/name> "Nemshan Alharthi"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/Briechenstein12> <https://www.wikidata.org/wiki/Property:P3919> <https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> .
<https://github.com/kwaikar/ml_marketplace> <https://schema.org/description> "My personal collection of sample notebooks that leverage products from AWS Marketplace for machine learning . Link - https://aws.amazon.com/marketplace/search/results?page=1&filters=fulfillment_options&fulfillment_options=SAGEMAKER&searchTerms="^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/piruty/gihyo-bayesian-filter> <https://schema.org/description> "gihyo.jp  \u300C\u6A5F\u68B0\u5B66\u7FD2 \u306F\u3058\u3081\u3088\u3046 \u00BB \u7B2C3\u56DE\u3000\u30D9\u30A4\u30B8\u30A2\u30F3\u30D5\u30A3\u30EB\u30BF\u3092\u5B9F\u88C5\u3057\u3066\u307F\u3088\u3046(http://gihyo.jp/dev/serial/01/machine-learning/0003?page=1)\u300D\u306E\u5199\u7D4C"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/jorgemachucav> <https://schema.org/identifier> "47221983"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/qasimwasfi> <https://schema.org/contributor> <https://github.com/qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution> .
<https://github.com/HowWeLand> <https://schema.org/image> <https://avatars3.githubusercontent.com/u/34463960?v=4> .
<https://github.com/kwwaikar> <https://www.wikidata.org/wiki/Property:P3919> <https://github.com/kwaikar/ml_marketplace> .
<https://github.com/EdwardTang> <https://schema.org/identifier> "3278807"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/piruty> <https://schema.org/contributor> <https://github.com/piruty/gihyo-bayesian-filter> .
<https://github.com/kakus5> <https://schema.org/BookmarkAction> <https://github.com/SOYJUN/Implement-ODR-protocol> .
<https://github.com/piruty/gihyo-bayesian-filter> <https://schema.org/dateCreated> "2016-01-19T07:05:25"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/zwlforever> <https://schema.org/identifier> "8939305"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/nileshlg2003> <https://schema.org/BookmarkAction> <https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> .
<https://github.com/qasimwasfi> <https://schema.org/identifier> "15672665"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/codemotionamsterdam> <https://schema.org/image> <https://avatars2.githubusercontent.com/u/38037497?v=4> .
<https://github.com/kakus5> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/SOYJUN> <https://www.wikidata.org/wiki/Property:P3919> <https://github.com/SOYJUN/Implement-ODR-protocol> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <https://schema.org/dateModified> "2019-02-24T08:27:06"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/uluumy> <https://schema.org/identifier> "20103069"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/qasimwasfi> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20204892> .
<https://github.com/qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution> <https://schema.org/codeRepository> <https://github.com/qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution> .
<https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> <https://schema.org/description> "Summary  In this article, we are going to present the solution for the Women\u2019s Health Risk Assessment data science competition on Microsoft\u2019s Cortana Intelligence platform which was ranked among the top 5%. In this page, you can find the published Azure ML Studio experiment., a description of the data science process used, and finally a link to the R code (in GitHub).   Competition Here is the description from the Microsoft Cortana Competition  \u201CTo help achieve the goal of improving women's reproductive health outcomes in underdeveloped regions, this competition calls for optimized machine learning solutions so that a patient can be accurately categorized into different health risk segments and subgroups. Based on the categories that a patient falls in, healthcare providers can offer an appropriate education and training program to patients. Such customized programs have a better chance to help reduce the reproductive health risk of patients. This dataset used in this competition was collected via survey in 2015 as part of a Bill & Melinda Gates Foundation funded project exploring the wants, needs, and behaviors of women and girls with regards to their sexual and reproductive health in nine geographies. The objective of this machine learning competition is to build machine learning models to assign a young woman subject (15-30 years old) in one of the 9 underdeveloped regions into a risk segment, and a subgroup within the segment.\u201D https://gallery.cortanaintelligence.com/Competition/Womens-Health-Risk-Assessment-1  Dataset The contains 9000 observations The original training dataset is in CSV format and can be found in the competition\u2019s description. To submit a solution, two options are possible: build it in Azure ML Studio or build your solutions locally in R and then submit it through Azure ML Studio.  An Azure ML\u2019s solution, and a R script code where given as example. The two solutions are based on the use of a Generalized Linear Model is automatically downloaded.  You can find a detailed description of the dataset, the R sample Code and a tutorial using Azure ML and R in the competition page   Solution I started following the R tutorial for this competition.  Then I have submitted the exact same R solution. The sample model has a 77% accuracy Pre-processing & Cleaning The first thing I did was changing the initial multinomial model (nnet package) for a random forest model (RandomForest package).  All missing values have been replaced by 0 Feature selection Features have been selected using the function varImpPlot from the randomforest package Parameter tuning I have chosen (for educational matter) to use the module Tune Model Hyperparameters in Azure ML Studio. I could have also used the R Package Caret. Evaluation The final model has an accuracy of 86.36% (18 position over almost 500 participants) You can download the R code here"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/codemotionamsterdam/codemotionrank> <https://schema.org/name> "codemotionamsterdam/codemotionrank"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/macosunity> <https://schema.org/BookmarkAction> <https://github.com/SOYJUN/Implement-ODR-protocol> .
<https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/zwlforever> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> <https://schema.org/dateCreated> "2018-04-05T19:05:50"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <https://schema.org/identifier> "33745048"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution> <https://schema.org/dateModified> "2018-07-30T08:37:57"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/kunal924> <https://schema.org/identifier> "46965735"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <https://schema.org/description> "Overview  For this assignment you will be developing and implementing :  An On-Demand shortest-hop Routing (ODR) protocol for networks of fixed but arbitrary and unknown connectivity, using PF_PACKET sockets. The implementation is based on (a simplified version of) the AODV algorithm.  Time client and server applications that send requests and replies to each other across the network using ODR. An API you will implement using Unix domain datagram sockets enables applications to communicate with the ODR mechanism running locally at their nodes. I shall be discussing the assignment in class on Wednesday, October 29, and Monday, November 3.  The following should prove useful reference material for the assignment :  Sections 15.1, 15.2, 15.4 & 15.6, Chapter 15, on Unix domain datagram sockets.  PF_PACKET(7) from the Linux manual pages. You might find these notes made by a past CSE 533 student useful. Also, the following link http://www.pdbuchan.com/rawsock/rawsock.html contains useful code samples that use PF_PACKET sockets (as well as other code samples that use raw IP sockets which you do not need for this assignment, though you will be using these types of sockets for Assignment 4). Charles E. Perkins & Elizabeth M. Royer. \u201CAd-hoc On-Demand Distance Vector Routing.\u201D Proceedings of the 2nd IEEE Workshop on Mobile Computing Systems and Applications, New Orleans, Louisiana, February 1999,  pp. 90 - 100.  The  VMware  environment  minix.cs.stonybrook.edu is a Linux box running VMware. A cluster of ten Linux virtual machines, called vm1 through vm10, on which you can gain access as root and run your code have been created on minix. See VMware Environment Hosts for further details.  VMware instructions  takes you to a page that explains how to use the system. The ten virtual machines have been configured into a small virtual intranet of Ethernet LANs whose topology is (in principle) unknown to you.  There is a course account cse533 on node minix, with home directory /users/cse533. In there, you will find a subdirectory Stevens/unpv13e , exactly as you are used to having on the cs system. You should develop your source code and makefiles for handing in accordingly. You will be  handing in  your source code on the minix node.  Note that you do not need to link against the socket library (-lsocket) in Linux. The same is true for -lnsl and -lresolv. For example, take a look at how the LIBS variable is defined for Solaris, in /home/courses/cse533/Stevens/unpv13e_solaris2.10/Make.defines (on compserv1, say) :  LIBS = ../libunp.a -lresolv -lsocket -lnsl -lpthread  But if you take a look at Make.defines on minix (/users/cse533/Stevens/unpv13e/Make.defines) you will find only:  LIBS = ../libunp.a -lpthread  The nodes vm1 , . . . . . , vm10 are all multihomed :  each has two (or more) interfaces. The interface  \u2018eth0 \u2019  should be completely ignored and is not to be used for this assignment (because it shows all ten nodes as if belonging to the same single Ethernet 192.168.1.0/24, rather than to an intranet composed of several Ethernets).  Note that vm1 , . . . . . , vm10 are virtual machines, not real ones. One implication of this is that you will not be able to find out what their (virtual) IP addresses are by using nslookup and such. To find out these IP addresses, you need to look at the file /etc/hosts on minix. More to the point, invoking gethostbyname for a given vm will return to you only the (primary) IP address associated with the interface eth0 of that vm (which is the interface you will not be using). It will not return to you any other IP address for the node. Similarly, gethostbyaddr will return the vm node name only if you give it the (primary) IP address associated with the interface eth0 for the node. It will return nothing if you give it any other IP address for the node, even though the address is perfectly valid. Because of this, and because it will ease your task to be able to use gethostbyname and gethostbyaddr in a straightforward way, we shall adopt the (primary) IP addresses associated with interfaces eth0 as the \u2018canonical\u2019 IP addresses for the nodes (more on this below).  Time client and server  A time server runs on each of the ten vm machines. The client code should also be available on each vm so that it can be evoked at any of them.  Normally, time clients/servers exchange request/reply messages using the TCP/UDP socket API that, effectively, enables them to receive service (indirectly, via the transport layer) from the local IP mechanism running at their nodes. You are to implement an API using Unix domain sockets to access the local ODR service directly (somewhat similar, in effect, to the way that raw sockets permit an application to access IP directly). Use Unix domain SOCK_DGRAM, rather than SOCK_STREAM, sockets (see Figures 15.5 & 15.6, pp. 418 - 419).  API  You need to implement a msg_send function that will be called by clients/servers to send requests/replies. The parameters of the function consist of : int          giving the socket descriptor for write char*     giving the \u2018canonical\u2019 IP address for the destination node, in presentation format int          giving the destination \u2018port\u2019 number char*     giving message to be sent int flag  if set, force a route rediscovery to the destination node even if a non-\u2018stale\u2019 route already exists (see below) msg_send will format these parameters into a single char sequence which is written to the Unix domain socket that a client/server process creates. The sequence will be read by the local ODR from a Unix domain socket that the ODR process creates for itself.  Recall that the \u2018canonical\u2019 IP address for a vm node is the (primary) IP address associated with the eth0 interface for the node. It is what will be returned to you by a call to gethostbyname.  Similarly, we need a msg_recv function which will do a (blocking) read on the application domain socket and return with : int       giving socket descriptor for read char*  giving message received char*  giving \u2018canonical\u2019 IP address for the source node of message, in presentation format int*     giving source \u2018port\u2019 number This information is written as a single char sequence by the ODR process to the domain socket that it creates for itself. It is read by msg_recv from the domain socket the client/server process creates, decomposed into the three components above, and returned to the caller of msg_recv.  Also see the section below entitled ODR and the API. Client  When a client is evoked at a node, it creates a domain datagram socket. The client should bind its socket to a \u2018temporary\u2019 (i.e., not \u2018well-known\u2019) sun_path name obtained from a call to tmpnam() (cf. line 10, Figure 15.6, p. 419) so that multiple clients may run at the same node.  Note that tmpnam() is actually highly deprecated. You should use the mkstemp() function instead - look up the online man pages on minix (\u2018man mkstemp\u2019) for details.   As you run client code again and again during the development stage, the temporary files created by the calls to tmpnam / mkstemp start to proliferate since these files are not automatically removed when the client code terminates. You need to explicitly remove the file created by the client evocation by issuing a call to unlink() or to remove() in your client code just before the client code exits. See the online man pages on minix (\u2018man unlink\u2019, \u2018man remove\u2019) for details. The client then enters an infinite loop repeating the steps below. The client prompts the user to choose one of vm1 , . . . . . , vm10 as a server node.  Client msg_sends a 1 or 2 byte message to server and prints out on stdout the message      client at node  vm i1  sending request to server at  vm i2 (In general, throughout this assignment, \u201Ctrace\u201D messages such as the one above should give the vm names and not IP addresses of the nodes.)  Client then blocks in msg_recv awaiting response. This attempt to read from the domain socket should be backed up by a timeout in case no response ever comes. I leave it up to you whether you \u2018wrap\u2019 the call to msg_recv in a timeout, or you implement the timeout inside msg_recv itself. When the client receives a response it prints out on stdout the message      client at node  vm i1 : received from   vm i2  <timestamp> If, on the other hand, the client times out, it should print out the message      client at node  vm i1 : timeout on response from   vm i2 The client then retransmits the message out, setting the flag parameter in msg_send to force a route rediscovery, and prints out an appropriate message on stdout. This is done only once, when a timeout for a given message to the server occurs for the first time.  Client repeats steps 1. - 3. Server  The server creates a domain datagram socket. The server socket is assumed to have a (node-local) \u2018well-known\u2019 sun_path name which it binds to. This \u2018well-known\u2019 sun_path name is designated by a (network-wide) \u2018well-known\u2019 \u2018port\u2019 value. The time client uses this \u2018port\u2019 value to communicate with the server.  The server enters an infinite sequence of calls to msg_recv followed by msg_send, awaiting client requests and responding to them. When it responds to a client request, it prints out on stdout the message                server at node  vm i1  responding to request from  vm i2 ODR  The ODR process runs on each of the ten vm machines. It is evoked with a single command line argument which gives a \u201Cstaleness\u201D time parameter, in seconds.  It uses get_hw_addrs (available to you on minix in ~cse533/Asgn3_code) to obtain the index, and associated (unicast) IP and Ethernet addresses for each of the node\u2019s interfaces, except for the eth0 and lo (loopback) interfaces, which should be ignored. In the subdirectory ~cse533/Asgn3_code (/users/cse533/Asgn3_code) on minix I am providing you with two functions, get_hw_addrs and prhwaddrs. These are analogous to the get_ifi_info_plus and prifinfo_plus of Assignment 2. Like get_ifi_info_plus, get_hw_addrs uses ioctl. get_hw_addrs gets the (primary) IP address, alias IP addresses (if any), HW address, and interface name and index value for each of the node's interfaces (including the loopback interface lo). prhwaddrs prints that information out. You should modify and use these functions as needed.  Note that if an interface has no HW address associated with it (this is, typically, the case for the loopback interface lo for example), then ioctl returns get_hw_addrs a HW address which is the equivalent of 00:00:00:00:00:00 .  get_hw_addrs stores this in the appropriate field of its data structures as it would with any HW address returned by ioctl, but when prhwaddrs comes across such an address, it prints a blank line instead of its usual \u2018HWaddr = xx:xx:xx:xx:xx:xx\u2019. The ODR process creates one or more PF_PACKET sockets. You will need to try out PF_PACKET sockets for yourselves and familiarize yourselves with how they behave. If, when you read from the socket and provide a sockaddr_ll structure, the kernel returns to you the index of the interface on which the incoming frame was received, then one socket will be enough. Otherwise, somewhat in the manner of Assignment 2, you shall have to create a PF_PACKET socket for every interface of interest (which are all the interfaces of the node, excluding interfaces lo and eth0 ), and bind a socket to each interface. Furthermore, if the kernel also returns to you the source Ethernet address of the frame in the sockaddr_ll structure, then you can make do with SOCK_DGRAM type PF_PACKET sockets; otherwise you shall have to use SOCK_RAW type sockets (although I would prefer you to use SOCK_RAW type sockets anyway, even if it turns out you can make do with SOCK_DGRAM type).  The socket(s) should have a protocol value (no larger than 0xffff so that it fits in two bytes; this value is given as a network-byte-order parameter in the call(s) to function socket) that identifies your ODR protocol. The <linux/if_ether.h> include file (i.e., the file /usr/include/linux/if_ether.h) contains protocol values defined for the standard protocols typically found on an Ethernet LAN, as well as other values such as ETH_P_ALL. You should set protocol to a value of your choice which is not a <linux/if_ether.h> value, but which is, hopefully, unique to yourself. Remember that you will all be running your code using the same root account on the vm1 , . . . . . , vm10 nodes. So if two of you happen to choose the same protocol value and happen to be running on the same vm node at the same time, your applications will receive each other\u2019s frames. For that reason, try to choose a protocol value for the socket(s) that is likely to be unique to yourself (something based on your Stony Brook student ID number, for example). This value effectively becomes the protocol value for your implementation of ODR, as opposed to some other cse 533 student's implementation. Because your value of protocol is to be carried in the frame type field of the Ethernet frame header, the value chosen should be not less than 1536 (0x600) so that it is not misinterpreted as the length of an Ethernet 802.3 frame.  Note from the man pages for packet(7) that frames are passed to and from the socket without any processing in the frame content by the device driver on the other side of the socket, except for calculating and tagging on the 4-byte CRC trailer for outgoing frames, and stripping that trailer before delivering incoming frames to the socket. Nevertheless, if you write a frame that is less than 60 bytes, the necessary padding is automatically added by the device driver so that the frame that is actually transmitted out is the minimum Ethernet size of 64 bytes. When reading from the socket, however, any such padding that was introduced into a short frame at the sending node to bring it up to the minimum frame size is not stripped off - it is included in what you receive from the socket (thus, the minimum number of bytes you receive should never be less than 60). Also, you will have to build the frame header for outgoing frames yourselves (assuming you use SOCK_RAW type sockets). Bear in mind that the field values in that header have to be in network order. The ODR process also creates a domain datagram socket for communication with application processes at the node, and binds the socket to a \u2018well known\u2019 sun_path name for the ODR service.  Because it is dealing with fixed topologies, ODR is, by and large, considerably simpler than AODV. In particular, discovered routes are relatively stable and there is no need for all the paraphernalia that goes with the possibility of routes changing (such as maintenance of active nodes in the routing tables and timeout mechanisms; timeouts on reverse links; lifetime field in the RREP messages; etc.)  Nor will we be implementing source_sequence_#s (in the RREQ messages), and dest_sequence_# (in RREQ and RREP messages). In reality, we should (though we will not, for the sake of simplicity, be doing so) implement some sort of sequence number mechanism, or some alternative mechanism such as split-horizon for example, if we are to avoid possible scenarios of routing loops in a \u201Ccount to infinity\u201D context (I shall explain this point in class).  However, we want ODR to discover shortest-hop paths, and we want it to do so in a reasonably efficient manner. This necessitates having one or two aspects of its operations work in a different, possibly slightly more complicated, way than AODV does. ODR has several basic responsibilities :  Build and maintain a routing table. For each destination in the table, the routing table structure should include, at a minimum, the next-hop node (in the form of the Ethernet address for that node) and outgoing interface index, the number of hops to the destination, and a timestamp of when the the routing table entry was made or last \u201Creconfirmed\u201D / updated. Note that a destination node in the table is to be identified only by its \u2018canonical\u2019 IP address, and not by any other IP addresses the node has.  Generate a RREQ in response to a time client calling msg_send for a destination for which ODR has no route (or for which a route exists, but msg_send has the flag parameter set or the route has gone \u2018stale\u2019 \u2013 see below), and \u2018flood\u2019 the RREQ out on all the node\u2019s interfaces (except for the interface it came in on and, of course, the interfaces eth0 and lo). Flooding is done using an Ethernet broadcast destination address (0xff:ff:ff:ff:ff:ff) in the outgoing frame header.   Note that a copy of the broadcast packet is supposed to / might be looped back to the node that sends it (see p. 535 in the Stevens textbook). ODR will have to take care not to treat these copies as new incoming RREQs.   Also note that ODR at the client node increments the broadcast_id every time it issues a new RREQ for any destination node. When a RREQ is received, ODR has to generate a RREP if it is at the destination node, or if it is at an intermediate node that happens to have a route (which is not \u2018stale\u2019 \u2013 see below) to the destination. Otherwise, it must propagate the RREQ by flooding it out on all the node\u2019s interfaces (except the interface the RREQ arrived on). Note that as it processes received RREQs, ODR should enter the \u2018reverse\u2019 route back to the source node into its routing table, or update an existing entry back to the source node if the RREQ received shows a shorter-hop route, or a route with the same number of hops but going through a different neighbour. The timestamp associated with the table entry should be updated whenever an existing route is either \u201Creconfirmed\u201D or updated. Obviously, if the node is going to generate a RREP, updating an existing entry back to the source node with a more efficient route, or a same-hops route using a different neighbour, should be done before the RREP is generated.  Unlike AODV, when an intermediate node receives a RREQ for which it generates a RREP, it should nevertheless continue to flood the RREQ it received if the RREQ pertains to a source node whose existence it has heretofore been unaware of, or the RREQ gives it a more efficient route than it knew of back to the source node (the reason for continuing to flood the RREQ is so that other nodes in the intranet also become aware of the existence of the source node or of the potentially more optimal reverse route to it, and update their tables accordingly). However, since an RREP for this RREQ is being sent by our node, we do not want other nodes who receive the RREQ propagated by our node, and who might be in a position to do so, to also send RREPs. So we need to introduce a field in the RREQ message, not present in the AODV specifications, which acts like a \u201CRREP already sent\u201D field. Our node sets this field before further propagating the RREQ and nodes receiving an RREQ with this field set do not send RREPs in response, even if they are in a position to do so.  ODR may, of course, receive multiple, distinct instances of the same RREQ (the combination of source_addr and broadcast_id uniquely identifies the RREQ). Such RREQs should not be flooded out unless they have a lower hop count than instances of that RREQ that had previously been received.  By the same token, if ODR is in a position to send out a RREP, and has already done so for this, now repeating, RREQ ,  it should not send out another RREP unless the RREQ shows a more efficient, previously unknown, reverse route back to the source node. In other words, ODR should not generate essentially duplicative RREPs, nor generate RREPs to instances of RREQs that reflect reverse routes to the source that are not more efficient than what we already have. Relay RREPs received back to the source node (this is done using the \u2018reverse\u2019 route entered into the routing table when the corresponding RREQ was processed). At the same time, a \u2018forward\u2019 path to the destination is entered into the routing table. ODR could receive multiple, distinct RREPs for the same RREQ. The \u2018forward\u2019 route entered in the routing table should be updated to reflect the shortest-hop route to the destination, and RREPs reflecting suboptimal routes should not be relayed back to the source. In general, maintaining a route and its associated timestamp in the table in response to RREPs received is done in the same manner described above for RREQs.  Forward time client/server messages along the next hop. (The following is important \u2013 you will lose points if you do not implement it.) Note that such application payload messages (especially if they are the initial request from the client to the server, rather than the server response back to the client) can be like \u201Cfree\u201D RREPs, enabling nodes along the path from source (client) to destination (server) node to build a reverse path back to the client node whose existence they were heretofore unaware of (or, possibly, to update an existing route with a more optimal one). Before it forwards an application payload message along the next hop, ODR at an intermediate node (and also at the final destination node) should use the message to update its routing table in this way. Thus, calls to msg_send by time servers should never cause ODR at the server node to initiate RREQs, since the receipt of a time client request implies that a route back to the client node should now exist in the routing table. The only exception to this is if the server node has a staleness parameter of zero (see below). A routing table entry has associated with it a timestamp that gives the time the entry was made into the table. When a client at a node calls msg_send, and if an entry for the destination node already exists in the routing table, ODR first checks that the routing information is not \u2018stale\u2019. A stale routing table entry is one that is older than the value defined by the staleness parameter given as a command line argument to the ODR process when it is executed. ODR deletes stale entries (as well as non-stale entries when the flag parameter in msg_send is set) and initiates a route rediscovery by issuing a RREQ for the destination node. This will force periodic updating of the routing tables to take care of failed nodes along the current path, Ethernet addresses that might have changed, and so on. Similarly, as RREQs propagate through the intranet, existing stale table entries at intermediate nodes are deleted and new route discoveries propagated. As noted above when discussing the processing of RREQs and RREPs, the associated timestamp for an existing table entry is updated in response to having the route either \u201Creconfirmed\u201D or updated (this applies to both reverse routes, by virtue of RREQs received, and to forward routes, by virtue of RREPs). Finally, note that a staleness parameter of 0 essentially indicates that the discovered route will be used only once, when first discovered, and then discarded. Effectively, an ODR with staleness parameter 0 maintains no real routing table at all ;  instead, it forces route discoveries at every step of its operation. As a practical matter, ODR should be run with staleness parameter values that are considerably larger than the longest RTT on the intranet, otherwise performance will degrade considerably (and collapse entirely as the parameter values approach 0). Nevertheless, for robustness, we need to implement a mechanism by which an intermediate node that receives a RREP or application payload message for forwarding and finds that its relevant routing table entry has since gone stale, can intiate a RREQ to rediscover the route it needs.  RREQ, RREP, and time client/server request/response messages will all have to be carried as encapsulated ODR protocol messages that form the data payload of Ethernet frames. So we need to design the structure of ODR protocol messages. The format should contain a type field (0 for RREQ, 1 for RREP, 2 for application payload ). The remaining fields in an ODR message will depend on what type it is. The fields needed for (our simplified versions of AODV\u2019s) RREQ and RREP should be fairly clear to you, but keep in mind that you need to introduce two extra fields:  The \u201CRREP already sent\u201D bit or field in RREQ messages, as mentioned above.  A \u201Cforced discovery\u201D bit or field in both RREQ and RREP messages:  When a client application forces route rediscovery, this bit should be set in the RREQ issued by the client node ODR.  Intermediate nodes that are not the destination node but which do have a route to the destination node should not respond with RREPs to an RREQ which has the forced discovery field set. Instead, they should continue to flood the RREQ so that it eventually reaches the destination node which will then respond with an RREP.  The intermediate nodes relaying such an RREQ must update their \u2018reverse\u2019 route back to the source node accordingly, even if the new route is less efficient (i.e., has more hops) than the one they currently have in their routing table.  The destination node responds to the RREQ with an RREP in which this field is also set.  Intermediate nodes that receive such a forced discovery RREP must update their \u2018forward\u2019 route to the destination node accordingly, even if the new route is less efficient (i.e., has more hops) than the one they currently have in their routing table.  This behaviour will cause a forced discovery RREQ to be responded to only by the destination node itself and not any other node, and will cause intermediate nodes to update their routing tables to both source and destination nodes in accordance with the latest routing information received, to cover the possibility that older routes are no longer valid because nodes and/or links along their paths have gone down. A type 2, application payload, message needs to contain the following type of information :  type  =  2 \u2018canonical\u2019 IP address of source node \u2018port\u2019 number of source application process (This, of course, is not a real port number in the TCP/UDP sense, but simply a value that ODR at the source node uses to designate the sun_path name for the source application\u2019s domain socket.) \u2018canonical\u2019 IP address of destination node \u2018port\u2019 number of destination application process (This is passed to ODR by the application process at the source node when it calls msg_send. Its designates the sun_path name for an application\u2019s domain socket at the destination node.) hop count (This starts at 0 and is incremented by 1 at each hop so that ODR can make use of the message to update its routing table, as discussed above.) number of bytes in application message The fields above essentially constitute a \u2018header\u2019 for the ODR message. Note that fields which you choose to have carry numeric values (rather than ascii characters, for example) must be in network byte order. ODR-defined numeric-valued fields in type 0, RREQ, and type 1, RREP, messages must, of course, also be in network byte order.  Also note that only the \u2018canonical\u2019 IP addresses are used for the source and destination nodes in the ODR header. The same has to be true in the headers for type 0, RREQ, and type 1, RREP, messages. The general rule is that ODR messages only carry \u2018canonical\u2019 IP node addresses.  The last field in the type 2 ODR message is essentially the data payload of the message.  application message given in the call to msg_send An ODR protocol message is encapsulated as the data payload of an Ethernet frame whose header it fills in as follows :  source address  =  Ethernet address of outgoing interface of the current node where ODR is processing the message. destination address  =  Ethernet broadcast address for type 0 messages; Ethernet address of next hop node for type 1 & 2 messages. protocol field  =  protocol value for the ODR PF_PACKET socket(s). Last but not least, whenever ODR writes an Ethernet frame out through its socket, it prints out on stdout the message      ODR at node  vm i1 : sending      frame  hdr    src  vm i1      dest  addr                                                       ODR msg      type n     src  vm i2      dest  vm i3 where addr is in presentation format (i.e., hexadecimal xx:xx:xx:xx:xx:xx) and gives the destination Ethernet address in the outgoing frame header. Other nodes in the message should be identified by their vm name. A message should be printed out for each packet sent out on a distinct interface.  ODR and the API  When the ODR process first starts, it must construct a table in which it enters all well-known \u2018port\u2019 numbers and their corresponding sun_path names. These will constitute permanent entries in the table.  Thereafter, whenever it reads a message off its domain socket, it must obtain the sun_path name for the peer process socket and check whether that name is entered in the table. If not, it must select an \u2018ephemeral\u2019 \u2018port\u2019 value by which to designate the peer sun_path name and enter the pair  < port value , sun_path name >  into the table. Such entries cannot be permanent otherwise the table will grow unboundedly in time, with entries surviving for ever, beyond the peer processes\u2019 demise. We must associate a time_to_live field with a non-permanent table entry, and purge the entry if nothing is heard from the peer for that amount of time. Every time a peer process for which a non-permanent table entry exists communicates with ODR, its time_to_live value should be reinitialized.  Note that when ODR writes to a peer, it is possible for the write to fail because the peer does not exist :  it could be a \u2018well-known\u2019 service that is not running, or we could be in the interval between a process with a non-permanent table entry terminating and the expiration of its time_to_live value. Notes  A proper implementation of ODR would probably require that RREQ and RREP messages be backed up by some kind of timeout and retransmission mechanism since the network transmission environment is not reliable. This would considerably complicate the implementation (because at any given moment, a node could have multiple RREQs that it has flooded out, but for which it has still not received RREPs; the situation is further complicated by the fact that not all intermediate nodes receiving and relaying RREQs necessarily lie on a path to the destination, and therefore should expect to receive RREPs), and, learning-wise, would not add much to the experience you should have gained from Assignment 2."^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/codemotionamsterdam> <https://www.wikidata.org/wiki/Property:P3919> <https://github.com/codemotionamsterdam/codemotionrank> .
<https://github.com/qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q206904> .
<https://github.com/uluumy> <https://schema.org/image> <https://avatars2.githubusercontent.com/u/20103069?v=4> .
<https://github.com/kwaikar/ml_marketplace> <https://schema.org/identifier> "172388731"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/EdwardTang> <https://schema.org/image> <https://avatars0.githubusercontent.com/u/3278807?v=4> .
<https://www.wikidata.org/wiki/Property:P1324> <http://www.w3.org/2002/07/owl#sameAs> <https://schema.org/SoftwareSourceCode> .
<https://github.com/kwwaikar> <https://schema.org/name> "Kanchan Waikar"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution> <https://schema.org/name> "qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/minedor26> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/piruty/gihyo-bayesian-filter> <https://schema.org/name> "piruty/gihyo-bayesian-filter"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/uluumy> <https://www.wikidata.org/wiki/Property:P3919> <https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> .
<https://github.com/macosunity> <https://schema.org/image> <https://avatars2.githubusercontent.com/u/3349399?v=4> .
<https://github.com/Briechenstein12> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/kwaikar> <https://schema.org/identifier> "15643464"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/piruty/gihyo-bayesian-filter> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/kunal924> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/kwaikar> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/piruty> <https://schema.org/name> "piruty"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/nileshlg2003> <https://schema.org/image> <https://avatars1.githubusercontent.com/u/4803667?v=4> .
<https://github.com/kunal924> <https://schema.org/BookmarkAction> <https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> .
<https://github.com/qasimwasfi> <https://www.wikidata.org/wiki/Property:P3919> <https://github.com/qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution> .
<https://github.com/Briechenstein12> <https://schema.org/name> "Saturnrem Android Blockchain"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/Briechenstein12> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20204892> .
<https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q28865> .
<https://github.com/kwaikar> <https://schema.org/contributor> <https://github.com/kwaikar/ml_marketplace> .
<https://github.com/kwaikar/ml_marketplace> <https://schema.org/name> "kwaikar/ml_marketplace"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/joeymcc> <https://schema.org/identifier> "45340042"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/kwaikar> <https://schema.org/image> <https://avatars3.githubusercontent.com/u/15643464?v=4> .
<https://github.com/piruty/gihyo-bayesian-filter> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> <https://schema.org/description> "Introduction The context is the 2016 public use NH medical claims files obtained from NH CHIS (Comprehensive Health Care Information System). The dataset contains Commercial Insurance claims, and a small fraction of Medicaid and Medicare payments for dually eligible people. The primary purpose of this assignment is to test machine learning (ML) skills in a real case analysis setting. You are expected to clean and process data and then apply various ML techniques like Linear and no linear models like regularized regression, MARS, and Partitioning methods. You are expected to use at least two of R, Python and JMP software.  Data details:  Medical claims file for 2016 contains ~17 millions rows and ~60 columns of data, containing ~6.5 million individual medical claims. These claims are all commercial claims that were filed by healthcare providers in 2016 in the state of NH. These claims were ~88% for residents of NH and the remaining for out of state visitors who sought care in NH. Each claim consists of one or more line items, each indicating a procedure done during the doctor\u2019s visit. Two columns indicating Billed amount and the Paid amount for the care provided, are of primary interest. The main objective is to predict \u201CPaid amount per procedure\u201D by mapping a plethora of features available in the dataset. It is also an expectation that you would create new features using the existing ones or external data sources.  Objectives: Step 1: Take a random sample of 1 million unique claims, such that all line items related to each claim are included in the sample. This will result in a little less than 3 million rows of data.  Step 2: Clean up the data, understand the distributions, and create new features if necessary.  Step 3: Run predictive models using validation method of your choice.  Step 4: Write a descriptive report (less than 10 pages) describing the process and your findings. "^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/kwwaikar> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20204892> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution> <https://schema.org/identifier> "142848147"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/kwaikar> <https://schema.org/author> <https://github.com/kwaikar/ml_marketplace> .
<https://github.com/kwaikar/ml_marketplace> <https://schema.org/dateCreated> "2019-02-24T20:50:23"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SuriyaaKudoIsc> <https://schema.org/identifier> "5073946"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/EdwardTang> <https://schema.org/name> "Edward Tang"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN> <https://schema.org/author> <https://github.com/SOYJUN/Implement-ODR-protocol> .
<https://github.com/kunal924> <https://schema.org/image> <https://avatars0.githubusercontent.com/u/46965735?v=4> .
<https://github.com/codemotionamsterdam> <https://schema.org/name> "Codemotion Amsterdam"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/piruty/gihyo-bayesian-filter> <https://schema.org/identifier> "49933497"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/macosunity> <https://schema.org/identifier> "3349399"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/joeymcc> <https://schema.org/image> <https://avatars0.githubusercontent.com/u/45340042?v=4> .
<https://github.com/kwaikar/ml_marketplace> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> <https://schema.org/dateCreated> "2016-11-01T23:54:14"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/piruty/gihyo-bayesian-filter> <https://schema.org/dateModified> "2016-01-19T07:07:31"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/kwaikar/ml_marketplace> <https://schema.org/dateModified> "2019-03-17T15:31:22"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/kakus5> <https://schema.org/image> <https://avatars0.githubusercontent.com/u/25538218?v=4> .
<https://github.com/kwaikar> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20204892> .
<https://github.com/nileshlg2003> <https://schema.org/identifier> "4803667"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> <https://schema.org/name> "Briechenstein12/Jerusalem2020j2IL-Repository"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/jorgemachucav> <https://schema.org/name> "JMV"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20204892> .
<https://github.com/SOYJUN> <https://schema.org/image> <https://avatars1.githubusercontent.com/u/8823580?v=4> .
<https://github.com/codemotionamsterdam> <https://schema.org/identifier> "38037497"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/SOYJUN> <https://schema.org/contributor> <https://github.com/SOYJUN/Implement-ODR-protocol> .
<https://github.com/codemotionamsterdam/codemotionrank> <https://schema.org/dateModified> "2019-03-05T13:10:28"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> <https://schema.org/dateCreated> "2012-07-29T03:17:52"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q55630549> .
<https://github.com/HowWeLand> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/kwaikar/ml_marketplace> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/kwaikar> <https://www.wikidata.org/wiki/Property:P3919> <https://github.com/kwaikar/ml_marketplace> .
<https://github.com/Briechenstein12> <https://schema.org/identifier> "1453935"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/SuriyaaKudoIsc> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/codemotionamsterdam/codemotionrank> <https://schema.org/description> "What is CodemotionRank?  CodemotionRank is part of the Codemotion Platform\u2019s online 24/7 experience. CodemotionRank is a place where programmers from all over the world come together to solve problems in a wide range of Computer Science domains such as algorithms, machine learning, or artificial intelligence, as well as to practice different programming paradigms like functional programming.  Our Coding Challenges Cover These Domains Algorithms Artificial Intelligence: Write an AI bot to play a 1-player game, or play against other AI bots! Distributed Systems Databases Mathematics Cryptography and Security Language Specific Domains: Test your coding chops with Java, C++, Ruby, Python, Linux shell, SQL, a variety of functional languages. Don\u2019t see what you\u2019re looking for? We\u2019re adding new domains all the time!  Why should you solve challenges? Learning. Expand your knowledge by learning new programming topics and techniques by going through our challenges and editorial solutions. We believe the best way to learn something is by doing it!  Community. We\u2019re constantly growing community of developers who discuss problems, learn, compete, and collaborate together online and offline.  For Fun. What\u2019s more exciting than solving challenging problems? We\u2019re constantly adding helpful features to make our platform the best possible experience, such as boilerplate code and animations that display when you\u2019re running code.  Jobs. Looking for a job at an awesome company? You can get hired by solving challenges! See our Jobs page for details.  Glory. As you solve more challenges, you earn points and move up the  CodemotionRank Leaderboard.  Sign up below and get started!"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <https://schema.org/name> "SOYJUN/Implement-ODR-protocol"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/Nemshan> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/kakus5> <https://schema.org/identifier> "25538218"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/nileshlg2003> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/Briechenstein12> <https://schema.org/author> <https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> .
<https://github.com/uluumy> <https://schema.org/author> <https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> .
<https://github.com/Nemshan> <https://schema.org/image> <https://avatars0.githubusercontent.com/u/37916757?v=4> .
<https://github.com/kashenfelter> <https://schema.org/name> "Kathy Targowski Ashenfelter"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/qasimwasfi/Hacker-rank-Matching-Book-Names-and-Descriptions-solution> <https://schema.org/description> "Our bot has crawled several product pages from the popular Indian e-commerce website, Flipkart.com. All of these pages are specifically about the most popular books being sold on Flipkart (at the time of the crawl).  Each page contained information for exactly one book. We noted down exactly two fields from each of these pages:  1. The name of the book. 2. Description fragment: The first few sentences of the description of the book, as displayed on the page. In some cases,  this string or text field might be terminated prematurely (i.e., not exactly at a word or a sentence boundary). Each of these text blocks is split into two parts of roughly equal length.  Set A contains the names of all the books. Set B contains the description fragments for all the books.  Both the Sets A and B are shuffled up, and the ordering of elements is lost.  Your task is to identify, for each name (a) in Set A, which is the correct corresponding text fragment (b) in Set B, such that, b was the descriptive fragment for the book named a.  Hints: Getting started - Think about using TF-IDF Scores (or a modification of it)  For those getting started with this fascinating domain of text classification, here's a wonderful Youtube video of Professor Christopher Manning from Stanford, explaining the TF-IDF , which you could consider using as a starting point.   Input Format  An Integer N on the first line. This is followed by 2N+1 lines.  Text fragments (numbered 1 to N) from Set A, each on a new line (so a total of N lines).  A separator with five asterisk marks \"*\" which indicates the end of Set A and the start of Set B.  Text fragments (numbered 1 to N) from Set B, each on a new line (so a total of N lines).  Output Format  N lines, each containing one integer.  The i-th line should contain an integer j such that the j-th element of Set A and the i-th element of Set B are a pair, i.e., both originally came from the same listing page on Flipkart.  Constraints  1 <= N <= 1000  No text fragment will have more than 10000 characters.  Sample Input  5 How to Be a Domestic Goddess : Baking and the Art of Comfort Cooking (Paperback) Embedded / Real-Time Systems 1st Edition (Paperback) The Merchant of Venice (Paperback) Lose a Kilo a Week (Paperback) Few Things Left Unsaid (Paperback) ***** Today the embedded systems are ubiquitous in occurrence, most significant in function and project an absolutely promising picture of developments in the near future. The Merchant Of Venice is one of Shakespeare's best known plays. How To Be A Domestic Goddess: Baking and the Art of Comfort Cooking is a bestselling cookbook by the famous chef Nigella Lawson who aims to introduce the art of baking through text with an emphasis. Lose A Kilo A Week is a detailed diet and weight loss plan, and also shows how to maintain the ideal weight after reaching it. Few Things Left Unsaid is a story of love, romance, and heartbreak. Sample Output  2 3 1 4 5 Explanation  Explaining the Input  The first line indicates that the test case contains the names and descriptions of five popular books listed on Flipkart.  The next five lines are the names of the books (i.e, Set A). After that, we have a separator. That is followed by five lines, each containing description fragments from Set B.  Explaining how we arrived at the Output  The first description, is visibly most closely related to the second book (Embedded / Real-Time Systems 1st Edition (Paperback)).  The second description, is clearly about the Merchant of Venice - which is the third book name in Set-A.  The third description is about Baking - and so, it corresponds to the first of the book names, in Set-A. Similarly, the fourth and fifth descriptions match best with the fourth and fifth book names (i.e, it so happens that they are already in order).  So, the expected output is 2, 3, 1, 4, 5 respectively.  Scoring  The weight for a test case will be proportional to the number of tests (book names) it contains. Two sample tests are available and visible on Compile & Test. A training driven approach or solution is not expected in this challenge, which is why no comprehensive training data has been provided.  Score = M * (C)/N Where M is the Maximum Score for the test case.  C = Number of correct answers in your output.  N = Total number of book names in the test set (which were divided into Set A and Set B respectively).  Note: Submissions will be disqualified if it is evident that the code has been written in such a way that the sample test case answers are hard-coded, or similar approaches, where the answer is not computed, but arrived at by trying to ensure the code matches the sample answers.  Timelimits  Timelimits can be seen here.  Libraries  Libraries available in our Machine Learning/Real Data challenges will be enabled for this contest and are listed here. Please note, that occasionally, a few functions or modules might not work in the constraints of our infrastructure. For instance, some modules try to run multiple threads (and fail). So please try importing the library and functions and cross checking if they work in our online editor in case you plan to develop a solution locally, and then upload to our site."^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/kashenfelter> <https://schema.org/BookmarkAction> <https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> .
<https://github.com/kwwaikar> <https://schema.org/contributor> <https://github.com/kwaikar/ml_marketplace> .
<https://github.com/macosunity> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/Nemshan> <https://schema.org/identifier> "37916757"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/kashenfelter> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/minedor26> <https://schema.org/identifier> "42230986"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/codemotionamsterdam/codemotionrank> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <https://schema.org/dateCreated> "2015-04-10T18:49:12"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/Nemshan> <https://schema.org/contributor> <https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> .
<https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> <https://schema.org/dateModified> "2018-12-01T08:10:35"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SuriyaaKudoIsc> <https://schema.org/BookmarkAction> <https://github.com/SOYJUN/Implement-ODR-protocol> .
<https://github.com/piruty> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/kwaikar/ml_marketplace> <https://schema.org/codeRepository> <https://github.com/kwaikar/ml_marketplace> .
<https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> <https://schema.org/dateModified> "2019-01-24T17:50:21"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/kwwaikar> <https://schema.org/identifier> "36546813"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/codemotionamsterdam/codemotionrank> <https://schema.org/codeRepository> <https://github.com/codemotionamsterdam/codemotionrank> .
<https://github.com/codemotionamsterdam> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20204892> .
<https://github.com/minedor26> <https://schema.org/BookmarkAction> <https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> .
<https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> <https://schema.org/name> "uluumy/Data4People-Women-s-Health-Risk-Assessment"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/piruty/gihyo-bayesian-filter> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q28865> .
<https://github.com/kwaikar> <https://schema.org/name> "Kanchan"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN> <https://schema.org/name> "JUN ZENG"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/qasimwasfi> <https://schema.org/name> "Muhammad Afzal"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/qasimwasfi> <https://schema.org/image> <https://avatars1.githubusercontent.com/u/15672665?v=4> .
<https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> <https://schema.org/codeRepository> <https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> .
<https://github.com/minedor26> <https://schema.org/image> <https://avatars0.githubusercontent.com/u/42230986?v=4> .
<https://github.com/kashenfelter> <https://schema.org/image> <https://avatars0.githubusercontent.com/u/32109425?v=4> .
<https://github.com/HowWeLand> <https://schema.org/BookmarkAction> <https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> .
<https://github.com/kwwaikar> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/uluumy> <https://schema.org/name> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/EdwardTang> <https://schema.org/BookmarkAction> <https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> .
<https://github.com/uluumy> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20204892> .
<https://github.com/EdwardTang> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/piruty> <https://www.wikidata.org/wiki/Property:P3919> <https://github.com/piruty/gihyo-bayesian-filter> .
<https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/zwlforever> <https://schema.org/image> <https://avatars3.githubusercontent.com/u/8939305?v=4> .
<https://github.com/piruty> <https://schema.org/author> <https://github.com/piruty/gihyo-bayesian-filter> .
<https://github.com/jorgemachucav> <https://schema.org/image> <https://avatars3.githubusercontent.com/u/47221983?v=4> .
<https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> <https://schema.org/description> " Search documentation... Support Dashboard Card Payments Quickstart Securely collect card information from your customers and create a card payment.  Supported cards Users in the United States can accept Visa Mastercard American Express Discover JCB Diners Club credit and debit cards.  Stripe also supports a range of additional payment methods, depending on the country of your Stripe account.  Accepting a card payment using Stripe is a two-step process, with a client-side and a server-side action:  From your website running in the customer\u2019s browser, Stripe securely collects your customer\u2019s payment information and returns a representative token. This, along with any other form data, is then submitted by the browser to your server. Using the token, your server-side code makes an API request to create a charge and complete the payment. Tokenization ensures that no sensitive card data ever needs to touch your server so your integration can operate in a PCI compliant way.  Step 1: Securely collecting payment information  Checkout reference Complete information about available options and parameters is provided in the Checkout reference.  The simplest way for you to securely collect and tokenize card information is with Checkout. It combines HTML, JavaScript, and CSS to create an embedded payment form. When your customer enters their payment information, the card details are validated and tokenized for your server-side code to use.  To see Checkout in action, click the button below, filling in the resulting form with:  Any random, syntactically valid email address (the more random, the better) One of Stripe\u2019s test card numbers, such as 4242 4242 4242 4242 Any three-digit CVC code Any expiration date in the future To get started, add the following code to your payment page, making sure that the form submits to your own server-side code:  <form action=\"your-server-side-code\" method=\"POST\">   <script     src=\"https://checkout.stripe.com/checkout.js\" class=\"stripe-button\"     data-key=\"pk_test_2DtHIU1N9li5GpmJjyxkQMHh\"     data-amount=\"999\"     data-name=\"Demo Site\"     data-description=\"Example charge\"     data-image=\"https://stripe.com/img/documentation/checkout/marketplace.png\"     data-locale=\"auto\">   </script> </form> We\u2019ve pre-filled the data-key attribute with your test publishable API key\u2014only you can see this value. When you\u2019re ready to go live with your payment form, you must replace the test key with your live key. Learn more about how the keys play into test and live modes.  Although optional, we highly recommend also having Checkout collect the user\u2019s ZIP code, as address and ZIP code verifications help reduce fraud. Add data-zip-code=\"true\" to the above and enable declines on verification failures in your account settings. You can also set Checkout to collect the user\u2019s full billing and shipping addresses (using the corresponding parameters).  Requiring more than the minimum information lowers the possibility of a payment being declined or disputed in the future. Any fraudulent payments that you process are ultimately your responsibility, so requiring a little more than the minimum amount of information is an effective way to combat fraud.  Radar, our modern suite of fraud protection tools, is only available to users who have implemented client-side tokenization. By doing so, it ensures that you can pass the necessary data required for our machine-learning fraud prevention models to make more accurate predictions.  The amount provided in the Checkout form code is only shown to the user. It does not set the amount that the customer will be charged\u2014you must also specify an amount when making a charge request. As you build your integration, make sure that your payment form and server-side code use the same amount to avoid confusion.  An alternative to the blue button demonstrated above is to implement a custom Checkout integration. The custom approach allows you to use any HTML element or JavaScript event to open Checkout, as well as be able to specify dynamic arguments, such as custom amounts.  Stripe.js and Elements If you\u2019d prefer to have complete control over the look and fel of your payment form, you can make use of Stripe.js and Elements, our pre-built UI components. Refer to our Elements quickstart to learn more.  Mobile SDKs Using our native mobile libraries for iOS and Android, Stripe can collect your customer\u2019s payment information from within your mobile app and create a token for your server-side code to use.  Step 2: Creating a charge to complete the payment  Once a token is created, your server-side code makes an API request to create a one-time charge. This request contains the token, currency, amount to charge, and any additional information you may want to pass (e.g., metadata).  curl Ruby Python PHP Java Node Go .NET curl https://api.stripe.com/v1/charges \\    -u sk_test_fyzWf8eDyljIob76fMVSwIsi: \\    -d amount=999 \\    -d currency=usd \\    -d description=\"Example charge\" \\    -d source=tok_6Pk6W3hFiGB7dyNavdvyrFkM These requests expect the ID of the Token (e.g., tok_KPte7942xySKBKyrBu11yEpf) to be provided as the value of the source parameter.  Tokens can only be used once, and within a few minutes of creation. Using this approach, your customers need to re-enter their payment details each time they make a purchase. You can also save card details with Stripe for later use. Using this method, returning customers can quickly make a payment without providing their card details again.  Next steps Congrats! You can now accept card payments with Stripe using Checkout. You may now want to check out these resources:  Creating charges Getting paid Managing your Stripe account Supported payment methods Saving cards Questions? We're always happy to help with code or other questions you might have! Search our documentation, contact support, or connect with our sales team. You can also chat live with other developers in #stripe on freenode.  Was this page helpful? Yes No"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/uluumy> <https://schema.org/contributor> <https://github.com/uluumy/Data4People-Women-s-Health-Risk-Assessment> .
<https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> <https://schema.org/codeRepository> <https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> .
<https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> <https://schema.org/codeRepository> <https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> .
<https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> <https://schema.org/identifier> "128251994"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/jorgemachucav> <https://schema.org/BookmarkAction> <https://github.com/SOYJUN/Implement-ODR-protocol> .
<https://github.com/SuriyaaKudoIsc> <https://schema.org/name> "Suriyaa Sundararuban"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/joeymcc> <https://schema.org/BookmarkAction> <https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> .
<https://github.com/piruty> <https://schema.org/image> <https://avatars3.githubusercontent.com/u/8793641?v=4> .
<https://github.com/Nemshan> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20204892> .
<https://github.com/SuriyaaKudoIsc> <https://schema.org/image> <https://avatars2.githubusercontent.com/u/5073946?v=4> .
<https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository> <https://schema.org/identifier> "5219695"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/HowWeLand> <https://schema.org/identifier> "34463960"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/codemotionamsterdam> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/Nemshan/predicting-Paid-amount-for-Claims-Data> <https://schema.org/name> "Nemshan/predicting-Paid-amount-for-Claims-Data"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/3D_triangulation> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/fanyang88/ARP_protocol> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/vamsi44/On-Demand-Shortest-Hop-Routing> <https://schema.org/name> "vamsi44/On-Demand-Shortest-Hop-Routing"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/particle-system> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/vamsi44> <https://schema.org/contributor> <https://github.com/vamsi44/On-Demand-Shortest-Hop-Routing> .
<https://github.com/SOYJUN/TCP-socket-client-server> <https://schema.org/name> "SOYJUN/TCP-socket-client-server"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/face-tracking> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/SOYJUN/SBUshell> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/vamsi44/On-Demand-Shortest-Hop-Routing> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/da-x-ace/On-Demand-Routing> <https://schema.org/dateCreated> "2013-01-31T02:40:54"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/ODR_protocol_implementation> <https://schema.org/identifier> "7361405"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/fanyang88/algorithms> <https://schema.org/name> "fanyang88/algorithms"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/Roman_Numeral_converter> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/SOYJUN/SBU-OS-proj> <https://schema.org/dateModified> "2015-04-30T01:58:30"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/da-x-ace> <https://schema.org/author> <https://github.com/da-x-ace/Address-Space-ops-in-Wrapfs> .
<https://github.com/SOYJUN/aws-sdk-ruby> <https://schema.org/description> "The official AWS SDK for Ruby."^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/arpitsardhana/ODR-on-local-LAN> <https://schema.org/dateCreated> "2016-01-06T20:38:11"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/jorgemachucav> <https://schema.org/name> "JMV"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/da-x-ace/On-Demand-Routing> <https://schema.org/name> "da-x-ace/On-Demand-Routing"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/omsanket/CourseraTest> <https://schema.org/description> "Coursera Test Repo"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/omsanket/FTP-using-UDP-socket-server-client-C-programming> <https://schema.org/identifier> "31005024"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/fanyang88/3D_triangulation> <https://schema.org/dateModified> "2015-03-01T15:41:43"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/Tic_Tac_Toe> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/fanyang88/Tic_Tac_Toe> <https://schema.org/dateCreated> "2015-10-05T22:16:59"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/vamsi44/Content-Security-Policy-Script-Nonce-Filter-for-Apache> <https://schema.org/dateModified> "2013-09-23T23:54:54"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/sreeks1812/Extended-attributes-support-for--wrapfs--stackable-file-system> <https://schema.org/dateCreated> "2013-09-15T02:26:49"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/da-x-ace/On-Demand-Routing> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/fanyang88/leetcode_java> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/da-x-ace> <https://schema.org/author> <https://github.com/da-x-ace/Reliable-UDP> .
<https://github.com/arpitsardhana/ODR-on-local-LAN> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/fanyang88/particle-system> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q251> .
<https://github.com/SOYJUN> <https://schema.org/author> <https://github.com/SOYJUN/C-Thread-Pool> .
<https://github.com/vamsi44/Extended-Integrity-Support-for--WRAPFS--File-System> <https://schema.org/codeRepository> <https://github.com/vamsi44/Extended-Integrity-Support-for--WRAPFS--File-System> .
<https://github.com/sreeks1812/system-call-to-check-integrity-of-a-file> <https://schema.org/name> "sreeks1812/system-call-to-check-integrity-of-a-file"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/omsanket> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20204892> .
<https://github.com/da-x-ace/Shared-and-Distributed-Memory-Randomized-Quick-Sort> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/SuriyaaKudoIsc> <https://schema.org/BookmarkAction> <https://github.com/SOYJUN/Implement-ODR-protocol> .
<https://github.com/da-x-ace> <https://schema.org/author> <https://github.com/da-x-ace/Authorship-Attribution> .
<https://github.com/SOYJUN/aws-sdk-ruby> <https://schema.org/codeRepository> <https://github.com/SOYJUN/aws-sdk-ruby> .
<https://github.com/sreeks1812/Address-space-operations-support-for--wrapfs--stackable-file-system> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/SOYJUN/threadpool-1> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/SOYJUN/threadpool-1> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q2407> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/sreeks1812> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/fanyang88/distributed-algorithm-implementation-maekawa-s-algorithm> <https://schema.org/name> "fanyang88/distributed-algorithm-implementation-maekawa-s-algorithm"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/JSON-java> <https://schema.org/name> "fanyang88/JSON-java"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/phpone> <https://schema.org/codeRepository> <https://github.com/fanyang88/phpone> .
<https://github.com/omsanket/Implementation-of-ODR-protocol-using-C-language> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/vamsi44> <https://schema.org/author> <https://github.com/vamsi44/Extended-Integrity-Support-for--WRAPFS--File-System> .
<https://github.com/da-x-ace/xcrypt-system-call> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/SOYJUN/SBU-OS-proj> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/sreeks1812/On-Demand-Distance-Vector-Routing-for-networks-of-arbitrary-and-unknown-connectivity> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/SOYJUN/chatRoom> <https://schema.org/dateCreated> "2015-10-25T01:57:43"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/omsanket/PreemptiveOS> <https://schema.org/dateModified> "2015-12-18T00:56:55"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/kakus5> <https://schema.org/identifier> "25538218"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/da-x-ace/Address-Space-ops-in-Wrapfs> <https://schema.org/name> "da-x-ace/Address-Space-ops-in-Wrapfs"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/da-x-ace/Shared-and-Distributed-Memory-Randomized-Quick-Sort> <https://schema.org/codeRepository> <https://github.com/da-x-ace/Shared-and-Distributed-Memory-Randomized-Quick-Sort> .
<https://github.com/da-x-ace> <https://schema.org/author> <https://github.com/da-x-ace/Android_Project_Yamba_Client> .
<https://github.com/SOYJUN/TCP-socket-client-server> <https://schema.org/dateCreated> "2015-04-10T18:12:23"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/Roman_Numeral_converter> <https://schema.org/dateModified> "2013-11-27T22:08:32"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/vamsi44/System-Call-for-checking-the-integrity-of-files> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/fanyang88/reliable_UDP> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/SOYJUN/SBUshell> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/macosunity> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/fanyang88> <https://schema.org/author> <https://github.com/fanyang88/Roman_Numeral_converter> .
<https://github.com/da-x-ace/System-Call-Inherit> <https://schema.org/dateCreated> "2013-01-31T02:50:24"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/da-x-ace/Reliable-UDP> <https://schema.org/dateCreated> "2013-01-31T02:41:47"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/vamsi44/Extended-Address-Space-Operations-Support-for--WRAPFS--File-System> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/fanyang88/reliable_UDP> <https://schema.org/name> "fanyang88/reliable_UDP"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/omsanket/PreemptiveOS> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/sreeks1812/Script-Nonce-Module-for-Apache> <https://schema.org/dateCreated> "2013-09-15T02:32:45"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/vamsi44> <https://schema.org/author> <https://github.com/vamsi44/System-Call-for-checking-the-integrity-of-files> .
<https://github.com/da-x-ace/openSSL-compatible-RSA-Engine> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q2407> .
<https://github.com/vamsi44/File-Transfer-Protocol> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/sreeks1812/Extended-attributes-support-for--wrapfs--stackable-file-system> <https://schema.org/name> "sreeks1812/Extended-attributes-support-for--wrapfs--stackable-file-system"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN/TCP-socket-client-server> <https://schema.org/identifier> "33743415"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/fanyang88/algorithms> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/da-x-ace/Reliable-UDP> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/fanyang88/JSON-java> <https://schema.org/dateModified> "2016-01-27T17:04:58"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/da-x-ace/openSSL-compatible-RSA-Engine> <https://schema.org/identifier> "7928870"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/fanyang88/reliable_UDP> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/macosunity> <https://schema.org/image> <https://avatars2.githubusercontent.com/u/3349399?v=4> .
<https://github.com/vamsi44/System-Call-for-checking-the-integrity-of-files> <https://schema.org/identifier> "12839186"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <https://schema.org/codeRepository> <https://github.com/SOYJUN/Implement-ODR-protocol> .
<https://github.com/da-x-ace/Boruvka-GPGPU> <https://schema.org/identifier> "7926946"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/omsanket/FTP-using-UDP-socket-server-client-C-programming> <https://schema.org/dateCreated> "2015-02-19T07:12:24"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <https://schema.org/identifier> "33745048"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/sreeks1812> <https://schema.org/author> <https://github.com/sreeks1812/Script-Nonce-Module-for-Apache> .
<https://github.com/SOYJUN/chatRoom> <https://schema.org/codeRepository> <https://github.com/SOYJUN/chatRoom> .
<https://github.com/vamsi44/File-Transfer-Protocol> <https://schema.org/identifier> "12839155"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/fanyang88/practise> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q2005> .
<https://github.com/da-x-ace/Misc> <https://schema.org/codeRepository> <https://github.com/da-x-ace/Misc> .
<https://github.com/SOYJUN/SBU-OS-proj> <https://schema.org/codeRepository> <https://github.com/SOYJUN/SBU-OS-proj> .
<https://github.com/fanyang88/phpone> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q59> .
<https://github.com/sreeks1812/On-Demand-Distance-Vector-Routing-for-networks-of-arbitrary-and-unknown-connectivity> <https://schema.org/codeRepository> <https://github.com/sreeks1812/On-Demand-Distance-Vector-Routing-for-networks-of-arbitrary-and-unknown-connectivity> .
<https://github.com/da-x-ace> <https://schema.org/contributor> <https://github.com/da-x-ace/On-Demand-Routing> .
<https://github.com/SOYJUN> <https://schema.org/contributor> <https://github.com/SOYJUN/Implement-ODR-protocol> .
<https://github.com/fanyang88> <https://schema.org/author> <https://github.com/fanyang88/phpone> .
<https://github.com/da-x-ace/Misc> <https://schema.org/name> "da-x-ace/Misc"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN/XMLParser> <https://schema.org/dateCreated> "2015-10-16T15:18:53"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/macosunity> <https://schema.org/BookmarkAction> <https://github.com/SOYJUN/Implement-ODR-protocol> .
<https://github.com/fanyang88/reliable_UDP> <https://schema.org/codeRepository> <https://github.com/fanyang88/reliable_UDP> .
<https://github.com/fanyang88/particle-system> <https://schema.org/dateModified> "2014-08-22T08:59:08"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/Application-with-raw-IP-sockets> <https://schema.org/description> "Overview  For this assignment you will be developing an application that uses raw IP sockets to \u2018walk\u2019 around an ordered list of nodes (given as a command line argument at the \u2018source\u2019 node, which is the node at which the tour was initiated), in a manner similar to the IP SSRR (Strict Source and Record Route) option. At each node, the application pings the preceding node in the tour. However, unlike the ping code in Stevens, you will be sending the ping ICMP echo request messages through a SOCK_RAW-type PF_PACKET socket and implementing ARP functionality to find the Ethernet address of the target node. Finally, when the \u2018walk\u2019 is completed, the group of nodes visited on the tour will exchange multicast messages. Your code will consist of two process modules, a \u2018Tour\u2019 application module (which will implement all the functionality outlined above, except for ARP activity) and an ARP module.  The following should prove to be useful reference material for the assignment:  Sections 21.2, 21.3, 21.6 and 21.10, Chapter 21, on Multicasting.  Sections 27.1 to 27.3, Chapter 27, on the IP SSRR option.  Sections 28.1 to 28.5, Chapter 28, on raw sockets, the IP_HDRINCL socket option, and ping.  Sections 15.5, Chapter 15, on Unix domain SOCK_STREAM sockets.  Figure 29.14,  p. 807, and the corresponding explanation on  p. 806, on filling in an IP header when the IP_HDRINCL socket option is in effect.  The Lecture Slides on  ARP & RARP  (especially Section 4.4, ARP Packet Format, and the Figure 4.3 it includes).  The link http://www.pdbuchan.com/rawsock/rawsock.html contains useful code samples that use IP raw sockets and PF_PACKET sockets. Note, in partcular, the code \u201Cicmp4_ll.c\u201D in Table 2 for building an echo request sent through a PF_PACKET SOCK_RAW socket.   The  VMware  environment  You will be using the same vm1 , . . . . . , vm10 nodes you used for Assignment 3. However, unlike Assignment 3, you should use only interfaces eth0 and their associated IP addresses and ignore the other Ethernet interfaces that nodes have (interfaces eth0 make vm1 , . . . . . , vm10 look as if they belong to the same Ethernet LAN segment IP network 130.245.156.0/24). Note that, apart from the primary IP addresses associated with interfaces eth0, some nodes might also have one or more alias IP addresses associated with their interface eth0.   Tour application module specifications  The application will create a total of four sockets: two IP raw sockets, a PF_PACKET socket and a UDP socket for multicasting.  We shall call the two IP raw sockets the \u2018rt \u2019 (\u2018route traversal\u2019) and \u2018pg \u2019 (\u2018ping\u2019) sockets, respectively. The rt socket should have the IP_HDRINCL option set. You will only be receiving ICMP echo reply messages through the pg socket (and not sending echo requests), so it does not matter whether it has the IP_HDRINCL option set or not.  The pg socket should have protocol value (i.e., protocol demultiplexing key in the IP header) IPPROTO_ICMP.  The rt socket should have a protocol value that identifies the application - i.e., some value other than the IPPROTO_XXXX values in  /usr/include/netinet/in.h. However, remember that you will all be running your code using the same root account on the vm1 , . . . . . , vm10 nodes. So if two of you happen to choose the same protocol value and happen to be running on the same vm node at the same time, your applications will receive each other\u2019s IP packets. For that reason, try to choose a protocol value for your rt socket that is likely to be unique to yourself.  The PF_PACKET socket should be of type SOCK_RAW (not SOCK_DGRAM). This socket should have a protocol value of  ETH_P_IP = 0x0800 (IPv4).  The UDP socket for multicasting will be discussed below. Note that, depending on how you choose to bind that socket, you might actually need to have two UDP sockets for multicast communication \u2013 see bottom of  p. 576, Section 21.10.  Your application will, of course, have to be running on every vm node that is included in the tour.  When evoking the application on the source node, the user supplies a sequence of vm node names (not IP addresses) to be visited in order. This command line sequence starts with the next node to be visited from the source node (i.e., it does not start with the source node itself). The sequence can include any number of repeated visits to the same node. For example, suppose that the source node is vm3 and the executable is called badr_tour :  [root@vm3/root]# badr_tour vm2 vm10 vm4 vm7 vm5 vm2 vm6 vm2 vm9 vm4 vm7 vm2 vm6 vm5 vm1 vm10 vm8  (but note that the tour does not necessarily have to visit every vm node; and the same node should not appear consequentively in the tour list \u2013 i.e., the next node on the tour cannot be the current node itself).  The application turns the sequence into a list of IP addresses for source routing. It also adds the IP address of the source node itself to the beginning of the list. The list thus produced will be carried as the payload of an IP packet, not as a SSRR option in the packet header. It is our application which will ensure that every node in the sequence is visited in order, not the IP SSRR capability.  The source node should also add to the list an IP multicast address and a port number of its choice. It should also join the multicast group at that address and port number on its UDP socket. The TTL for outgoing multicasts should be set to 1.  The application then fills in the header of an IP packet, designating itself as the IP source, and the next node to be visited as the IP destination. The packet is sent out on the rt socket. Note that on Linux, all the fields of the packet header must be in network byte order (Stevens, Section 28.3, p. 737, the fourth bullet point).  When filling in the packet header, you should explicitly fill in the identification field (recall that, with the IP_HDRINCL socket option, if the identification field is given value 0, then the kernel will set its value). Try to make sure that the value you choose is likely to be unique to yourself (for reasons similar to those explained with respect to the IPPROTO_XXXX in 1. above).   When a node receives an IP packet on its rt socket, it should first check that the identification field carries the right value (this implies that you will hard code your choice of identification field value determined in item 2 above in your code). If the identification field value does not check out, the packet is ignored. For a valid packet :  Print out a message along the lines of: <time>   received source routing packet from <hostname> <time> is the current time in human-readable format (see lines 19 & 20 in Figure 1.9,  p. 14, and the corresponding explanation on  p. 14f.), and <hostname> is the host name corresponding to the source IP address in the header of the received packet.  If this is the first time the node is visited, the application should use the multicast address and port number in the packet received to join the multicast group on its UDP socket. The TTL for outgoing multicasts should be set to 1.  The application updates the list in the payload, so that the next node in the tour can easily identify what the next hop from itself will be when it receives the packet. How you do this I leave up to you. You could, for example, include as part of the payload a pointer field into the list of nodes to be visited. This pointer would then be updated to the next entry in the list as the packet progresses hop by hop (see Figure 27.1 and the associated explanation on  pp. 711-712). Other solutions are, of course, possible. The application then fills in a new IP header, designating itself as the IP source, and the next node to be visited as the IP destination. The identification field should be set to the same value as in the received packet. The packet is sent out on the rt socket.  The node should also initiate pinging to the preceding node in the tour (the IP address of which it should pick up from the header of the received packet). However, unlike the Stevens ping code, it will be using the SOCK_RAW-type PF_PACKET socket of item 1 above to send the ICMP echo request messages.  Before it can send echo request messages, the application has to call on the ARP module you will implement to get the Ethernet address of this preceding / \u2018target\u2019 node; this call is made using the API function areq which you will also implement (see sections ARP module specifications & API specifications below). Note that ARP has to be evoked every time the application wants to send out an echo request message, and not just the first time.  An echo request message has to be encapsulated in a properly-formulated IP packet, which is in turn encapsulated in a properly-formulated Ethernet frame transmitted out through the PF_PACKET socket ;  otherwise, ICMP at the source node will not receive it. You will have to modify Stevens\u2019 ping code accordingly, specifically, the send_v4 function. In particular, the Ethernet frame must have a value of  ETH_P_IP = 0x0800 (IPv4 \u2013 see <linux/if_ether.h>) in the frame type / \u2018length\u2019 field ;  and the encapsulated IP packet must have a value of  IPPROTO_ICMP = 0x01 (ICMPv4 \u2013 see <netinet_in.h>) in its protocol field.  You should also simplify the ping code in its entirety by stripping all the \u2018indirection\u2019 IPv4 / IPv6 dual-operability paraphernalia and making the code work just for IPv4. Also note that the functions host_serv and freeaddrinfo, together with the associated structure addrinfo (see Sections 11.6, 11.8 & 11.11), in Figures 27.3, 27.6 & 28.5 ( pp. 713, 716 & 744f., respectively) can be replaced by the function gethostbyname and associated structure hostent (see Section 11.3) where needed. Also, there is no \u2018-v\u2019 verbose option, so this too should be stripped from Stevens\u2019 code.  When a node is ready to start pinging, it first prints out a \u2018PING\u2019 message similar to lines 32-33 of Figure 28.5,  p. 744. It then builds up ICMP echo request messages and sends them to the source node every 1 second through the PF_PACKET socket. It also reads incoming echo response messages off the pg socket, in response to which it prints out the same kind of output as the code of Figure 28.8,  p. 748.  If this node and its preceding node have been previously visited in that order during the tour, then pinging would have already been initiated from the one to the other in response to the first visit, and nothing further should nor need be done during second and subsequent visits.  In light of the above, note that once a node initiates pinging, it needs to read from both its rt and pg sockets, necessitating the use of the select function. As will be clear from what follows below, the application will anyway be needing also to simultaneously monitor its UDP socket for incoming multicast datagrams.  When the last node on the tour is reached, and if this is the first time it is visited, it joins the multicast group and starts pinging the preceding node (if it is not already doing so). After a few echo replies are received (five, say), it sends out the multicast message below on its UDP socket (i.e., the node should wait about five seconds before sending the multicast message) :  <<<<< This is node vmi .  Tour has ended .  Group members please identify yourselves. >>>>>  where vmi is the name (not IP address) of the node. The node should also print this message out on stdout preceded, on the same line, by the phrase:  Node vmi .  Sending: <then print out the message sent>. Each node vmj receiving this message should print out the message received preceded, on the same line, by the phrase:  Node vmj .  Received <then print out the message received>.  Each such node in step a above should then immediately stop its pinging activity.  The node should then send out the following multicast message: <<<<< Node vmj .  I am a member of the group. >>>>> and print out this message preceded, on the same line, by the phrase:  Node vmj .  Sending: <then print out the message sent>.  Each node receiving these second multicast messages (i.e., the messages that nodes \u2013 including itself \u2013 sent out in step c above) should print each such message out preceded, on the same line, by the phrase:  Node vmk .  Received: <then print out the message received>.  Reading from the socket in step d above should be implemented with a 5-second timeout. When the timeout expires, the node should print out another message to the effect that it is terminating the Tour application, and gracefully exit its Tour process.  Note that under Multicast specifications, the last node in the tour, which sends out the End of Tour message, should itself receive a copy of that message and, when it does, it should behave exactly as do the other nodes in steps a. \u2013 e. above.  ARP module specifications  Your executable is evoked with no command line arguments. Like the Tour module, it will be running on every vm node.  It uses the get_hw_addrs function of Assignment 3 to explore its node\u2019s interfaces and build a set of  <IP address , HW address>  matching pairs for all eth0 interface IP addresses (including alias IP addresses, if any).  Write out to stdout in some appropriately clear format the address pairs found.  The module creates two sockets: a PF_PACKET socket and a Unix domain socket.  The PF_PACKET should be of type SOCK_RAW (not type SOCK_DGRAM) with a protocol value of your choice (but not one of the standard values defined in <linux/if_ether.h>) which is, hopefully, unique to yourself. This value effectively becomes the protocol value for your implementation of ARP. Because this protocol value will be carried in the frame type / \u2018length\u2019 field of the Ethernet frame header (see Figure 4.3 of the ARP & RARP handout), the value chosen should be not less than 1536 (0x600) so that it is not misinterpreted as the length of an Ethernet 802.3 frame.  The Unix domain socket should be of type SOCK_STREAM (not SOCK_DGRAM). It is a listening socket bound to a \u2018well-known\u2019 sun_path file. This socket will be used to communicate with the function areq that is implemented in the Tour module (see the section API specifications below). In this context, areq will act as the client and the ARP module as the server.  The ARP module then sits in an infinite loop, monitoring these two sockets.  As ARP request messages arrive on the PF_PACKET socket, the module processes them, and responds with ARP reply messages as appropriate.  The protocol builds a \u2018cache\u2019 of matching  <IP address , HW address>  pairs from the replies (and requests \u2013 see below) it receives. For simplicity, and unlike the real ARP, we shall not implement timing out mechanisms for these cache entries.  A cache entry has five parts: (i) IP address ;  (ii) HW address ;  (iii) sll_ifindex (the interface to be used for reaching the matching pair <(i) , (ii)>) ;  (iv) sll_hatype ;  and (v) a Unix-domain connection-socket descriptor for a connected client (see the section API specifications below for the latter three). When an ARP reply is being entered in the cache, the ARP module uses the socket descriptor in (v) to send a reply to the client, closes the connection socket, and deletes the socket descriptor from the cache entry.  Note that, like the real ARP, when an ARP request is received by a node, and if the request pertains to that receiving node, the sender\u2019s (see Figure 4.3 of the ARP & RARP handout) <IP address, HW address> matching pair should be entered into the cache if it is not already there (together, of course, with (iii) sll_ifindex &  (iv) sll_hatype), or updated if need be if such an entry already exists in the cache.  If the ARP request received does not pertain to the node receiving it, but there is already an entry in that receiving node's cache for the sender\u2019s <IP address, HW address> matching pair, that entry should be checked and updated if need be. If there is no such entry, no action is taken (in particular, and unlike the case above, no new entry should be made in the receiving node's cache of the sender\u2019s <IP address, HW address> matching pair if such an entry does not already exist).  ARP request and reply messages have the same format as Figure 4.3 of the ARP & RARP handout, but with an extra 2-byte identification field added at the beginning which you fill with a value chosen so that it has a high probability of being unique to yourself. This value is to be echoed in the reply message, and helps to act as a further filter in case some other student happens to have fortuitously chosen the same value as yourself for the protocol parameter of the ARP PF_PACKET. Values in the fields of our ARP messages must be in network byte order. You might find the system header file <linux/if_arp.h> useful for manipulating ARP request and reply messages, but remember that our version of these messages have an extra two-byte field as mentioned above.  Your code should print out on stdout, in some appropriately clear format, the contents of the Ethernet frame header and ARP request message you send. As described in Section 4.4 of the ARP & RARP handout, the node that responds to the request should, in its reply message, swap the two sender addresses with the two target addresses, as well as, of course, echo back the extra identification field sent with the request. The protocol at this responding node should print out, in an appropriately clear format, both the request frame (header and ARP message) it receives and the reply frame it sends. Similarly, the node that sent the request should print out the reply frame it receives. Finally, recall that the node issuing the request sends out a broadcast Ethernet frame, but the responding node replies with a unicast frame.  API specifications  The API is for communication between the Tour process and the ARP process. It consists of a single function, areq, implemented in the Tour module. areq is called by send_v4 function of the application every time the latter want to send out an ICMP echo request message: int areq (struct sockaddr *IPaddr, socklen_t sockaddrlen, struct hwaddr *HWaddr); IPaddr contains the primary or alias IPaddress of a \u2018target\u2019 node on the LAN for which the corresponding hardware address is being requested.  hwaddr is a new structure (and not a pre-existing type) modeled on the sockaddr_ll of PF_PACKET; you will have to declare it in your code. It is used to return the requested hardware address to the caller of areq :  structure hwaddr { 		     int             sll_ifindex;	 /* Interface number */ 		     unsigned short  sll_hatype;	 /* Hardware type */ 		     unsigned char   sll_halen;		 /* Length of address */ 		     unsigned char   sll_addr[8];	 /* Physical layer address */ }; areq creates a Unix domain socket of type SOCK_STREAM and connects to the \u2018well-known\u2019 sun_path file of the ARP listening socket. It sends the IP address from parameter IPaddr and the information in the three fields of parameter HWaddr to ARP. It then blocks on a read awaiting a reply from ARP. This read should be backed up by a timeout since it is possible that no reply is received for the request. If a timeout occurs, areq should close the socket and return to its caller indicating failure (through its int return value).  Your application code should print out on stdout, in some appropriately clear format, a notification every time areq is called, giving the IP address for which a HW address is being sought. It should similarly print out the result when the call to areq returns (HW address returned, or failure).  When the ARP module receives a request for a HW address from areq through its Unix domain listening socket, it first checks if the required HW address is already in the cache. If so, it can respond immediately to the areq and close the Unix domain connection socket.  Else :  it makes an \u2018incomplete\u2019 entry in the cache, consisting of parts (i), (iii), (iv) and (v) ;  puts out an ARP request message on the network on its PF_PACKET socket; and starts monitoring the areq connection socket for readability  \u2013  if the areq client closes the connection socket (this would occur in response to a timeout in areq), ARP deletes the corresponding incomplete entry from the cache (and ignores any subsequent ARP reply from the network if such is received). On the other hand, if ARP receives a reply from the network, it updates the incomplete cache entry, responds to areq, and closes the connection socket."^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88> <https://schema.org/identifier> "1666725"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/SOYJUN> <https://schema.org/author> <https://github.com/SOYJUN/chatRoom> .
<https://github.com/omsanket/TCP-socket-server-client-C-programming> <https://schema.org/codeRepository> <https://github.com/omsanket/TCP-socket-server-client-C-programming> .
<https://github.com/fanyang88/particle-system> <https://schema.org/dateCreated> "2012-04-22T15:56:17"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/omsanket/SB_SHELL> <https://schema.org/dateCreated> "2015-02-26T23:49:57"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/sreeks1812/Extended-attributes-support-for--wrapfs--stackable-file-system> <https://schema.org/identifier> "12839331"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/fanyang88/friendface> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/omsanket/Implementation-of-ODR-protocol-using-C-language> <https://schema.org/identifier> "31005279"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/sreeks1812/Adding-reliability-to-UDP> <https://schema.org/dateModified> "2014-10-28T22:50:12"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/arpitsardhana> <https://schema.org/name> "Arpit Singh"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/sreeks1812/Adding-reliability-to-UDP> <https://schema.org/codeRepository> <https://github.com/sreeks1812/Adding-reliability-to-UDP> .
<https://github.com/sreeks1812/Extended-attributes-support-for--wrapfs--stackable-file-system> <https://schema.org/dateModified> "2019-02-26T08:58:35"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/omsanket/FTP-using-UDP-socket-server-client-C-programming> <https://schema.org/dateModified> "2015-02-19T07:19:48"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/vamsi44/Extended-Integrity-Support-for--WRAPFS--File-System> <https://schema.org/identifier> "12839140"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/kakus5> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/fanyang88/ChatApp--p2p> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/SOYJUN/TCP-socket-client-server> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/da-x-ace/Android_Project_Yamba_Client> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q251> .
<https://github.com/fanyang88/leetcode_java> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/sreeks1812/Script-Nonce-Module-for-Apache> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/fanyang88/scraper> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/da-x-ace/multicast-tour-application> <https://schema.org/dateModified> "2014-03-15T13:39:46"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/omsanket> <https://schema.org/author> <https://github.com/omsanket/Implementation-of-ODR-protocol-using-C-language> .
<https://github.com/fanyang88/scraper> <https://schema.org/codeRepository> <https://github.com/fanyang88/scraper> .
<https://github.com/fanyang88/Distributed-algorithm-Majority-voting> <https://schema.org/dateCreated> "2012-12-29T01:06:13"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/da-x-ace/Boruvka-GPGPU> <https://schema.org/dateCreated> "2013-01-31T00:17:21"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/Roman_Numeral_converter> <https://schema.org/name> "fanyang88/Roman_Numeral_converter"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/arpitsardhana> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/fanyang88> <https://schema.org/author> <https://github.com/fanyang88/ChatApp--p2p> .
<https://github.com/sreeks1812> <https://schema.org/author> <https://github.com/sreeks1812/On-Demand-Distance-Vector-Routing-for-networks-of-arbitrary-and-unknown-connectivity> .
<https://github.com/omsanket/Implementation-of-ODR-protocol-using-C-language> <https://schema.org/dateCreated> "2015-02-19T07:23:40"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/omsanket/PreemptiveOS> <https://schema.org/codeRepository> <https://github.com/omsanket/PreemptiveOS> .
<https://github.com/da-x-ace/Android_Project_Yamba_Client> <https://schema.org/identifier> "23155679"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/da-x-ace/Authorship-Attribution> <https://schema.org/name> "da-x-ace/Authorship-Attribution"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN/SBUshell> <https://schema.org/name> "SOYJUN/SBUshell"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/phpone> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/sreeks1812/system-call-to-check-integrity-of-a-file> <https://schema.org/dateCreated> "2013-09-12T21:06:02"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/vamsi44/Extended-Integrity-Support-for--WRAPFS--File-System> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/fanyang88/phpone> <https://schema.org/dateModified> "2014-04-27T16:17:03"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/omsanket/PreemptiveOS> <https://schema.org/dateCreated> "2015-12-18T00:49:33"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/threadPool-POXIS-thread> <https://schema.org/dateCreated> "2015-11-11T18:20:22"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/ARP_protocol> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/sreeks1812> <https://schema.org/author> <https://github.com/sreeks1812/Address-space-operations-support-for--wrapfs--stackable-file-system> .
<https://github.com/omsanket/-Tour-Application-using-C-language> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/vamsi44/Content-Security-Policy-Script-Nonce-Filter-for-Apache> <https://schema.org/name> "vamsi44/Content-Security-Policy-Script-Nonce-Filter-for-Apache"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/omsanket/CourseraTest> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/vamsi44/Extended-Integrity-Support-for--WRAPFS--File-System> <https://schema.org/dateCreated> "2013-09-15T02:06:54"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/practise> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/vamsi44> <https://schema.org/image> <https://avatars0.githubusercontent.com/u/5461228?v=4> .
<https://github.com/vamsi44> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20204892> .
<https://github.com/fanyang88/ChatApp--p2p> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/da-x-ace/Address-Space-ops-in-Wrapfs> <https://schema.org/dateCreated> "2013-01-31T02:31:59"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/kakus5> <https://schema.org/image> <https://avatars0.githubusercontent.com/u/25538218?v=4> .
<https://github.com/SuriyaaKudoIsc> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/fanyang88/ODR_protocol_implementation> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/arpitsardhana/ODR-on-local-LAN> <https://schema.org/codeRepository> <https://github.com/arpitsardhana/ODR-on-local-LAN> .
<https://github.com/da-x-ace/Shared-and-Distributed-Memory-Randomized-Quick-Sort> <https://schema.org/dateCreated> "2013-01-31T02:42:42"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/ChatApp--p2p> <https://schema.org/name> "fanyang88/ChatApp--p2p"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/ODR_protocol_implementation> <https://schema.org/name> "fanyang88/ODR_protocol_implementation"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/zwlforever> <https://schema.org/identifier> "8939305"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/da-x-ace> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20204892> .
<https://github.com/da-x-ace/multicast-tour-application> <https://schema.org/identifier> "7928857"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/SOYJUN/chatRoom> <https://schema.org/identifier> "44892645"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/arpitsardhana> <https://schema.org/image> <https://avatars3.githubusercontent.com/u/9325553?v=4> .
<https://github.com/fanyang88/leetcode-in-js> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/ARP_protocol> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/fanyang88/practise> <https://schema.org/name> "fanyang88/practise"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN/aws-sdk-ruby> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/fanyang88/Roman_Numeral_converter> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q251> .
<https://github.com/da-x-ace> <https://schema.org/author> <https://github.com/da-x-ace/SuperComputing-HW3> .
<https://github.com/SOYJUN/SBUshell> <https://schema.org/dateCreated> "2015-04-10T18:59:57"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/registerSys> <https://schema.org/codeRepository> <https://github.com/SOYJUN/registerSys> .
<https://github.com/fanyang88/leetcode-in-js> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/da-x-ace> <https://schema.org/author> <https://github.com/da-x-ace/On-Demand-Routing> .
<https://github.com/SOYJUN/threadPool-POXIS-thread> <https://schema.org/identifier> "46000745"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/SOYJUN/XMLParser> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q2407> .
<https://github.com/vamsi44/Extended-Integrity-Support-for--WRAPFS--File-System> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/da-x-ace/xcrypt-system-call> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/SOYJUN/SBU-OS-proj> <https://schema.org/description> "Preemptive OS"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/face-tracking> <https://schema.org/name> "fanyang88/face-tracking"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/sreeks1812/Script-Nonce-Module-for-Apache> <https://schema.org/dateModified> "2013-09-24T03:17:54"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/distributed-algorithm-implementation-maekawa-s-algorithm> <https://schema.org/dateModified> "2014-03-04T12:36:35"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/Application-with-raw-IP-sockets> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/omsanket/FTP-using-UDP-socket-server-client-C-programming> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/sreeks1812/Address-space-operations-support-for--wrapfs--stackable-file-system> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/sreeks1812/Extended-attributes-support-for--wrapfs--stackable-file-system> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/da-x-ace> <https://schema.org/author> <https://github.com/da-x-ace/Misc> .
<https://github.com/SOYJUN/threadPool-POXIS-thread> <https://schema.org/dateModified> "2018-12-10T04:16:24"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/vamsi44/System-Call-for-checking-the-integrity-of-files> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/da-x-ace/Android_Project_Yamba_Client> <https://schema.org/name> "da-x-ace/Android_Project_Yamba_Client"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/vamsi44/Extended-Address-Space-Operations-Support-for--WRAPFS--File-System> <https://schema.org/dateCreated> "2013-09-15T02:11:40"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/aws-sdk-ruby> <https://schema.org/name> "SOYJUN/aws-sdk-ruby"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/sreeks1812/Adding-reliability-to-UDP> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/vamsi44/File-Transfer-Protocol> <https://schema.org/name> "vamsi44/File-Transfer-Protocol"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN/registerSys> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q2407> .
<https://github.com/omsanket/FTP-using-UDP-socket-server-client-C-programming> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/da-x-ace> <https://schema.org/name> "Prankur Gupta"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN/threadpool-1> <https://schema.org/codeRepository> <https://github.com/SOYJUN/threadpool-1> .
<https://github.com/da-x-ace/Boruvka-GPGPU> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q2407> .
<https://github.com/da-x-ace/openSSL-compatible-RSA-Engine> <https://schema.org/dateModified> "2013-10-07T04:16:27"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/reliable_UDP> <https://schema.org/dateCreated> "2012-12-29T00:34:00"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/vamsi44/System-Call-for-checking-the-integrity-of-files> <https://schema.org/description> "Implemented and added a system call as a module to the Linux kernel (Vanilla 3.2). It checks the integrity of the existing files in three modes. The system call also computes and updates the integrity if the file is modified and returns a file descriptor to the user to perform file operations."^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/da-x-ace/Android_Project_Yamba_Client> <https://schema.org/dateCreated> "2014-08-20T16:29:32"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/XMLParser> <https://schema.org/description> "[TOOL]: used to parse the XML file"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/da-x-ace/Boruvka-GPGPU> <https://schema.org/name> "da-x-ace/Boruvka-GPGPU"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/da-x-ace/Shared-and-Distributed-Memory-Randomized-Quick-Sort> <https://schema.org/dateModified> "2014-06-10T05:47:11"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/3D_triangulation> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q251> .
<https://github.com/fanyang88/practise> <https://schema.org/identifier> "71492906"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/da-x-ace/On-Demand-Routing> <https://schema.org/description> "Implemented On-demand Routing (ODR) protocol using OSI Layer 2 sockets (PF_PACKET) and UNIX domain sockets. Designed Client and Server applications that communicate with underlying ODR using UNIX domain sockets to exchange messages."^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/vamsi44/Extended-Integrity-Support-for--WRAPFS--File-System> <https://schema.org/name> "vamsi44/Extended-Integrity-Support-for--WRAPFS--File-System"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN> <https://schema.org/author> <https://github.com/SOYJUN/FTP-implement-based-on-UDP> .
<https://github.com/fanyang88> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20204892> .
<https://github.com/da-x-ace> <https://schema.org/author> <https://github.com/da-x-ace/Boruvka-GPGPU> .
<https://github.com/fanyang88/scraper> <https://schema.org/dateCreated> "2018-12-20T21:33:24"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/da-x-ace/Boruvka-GPGPU> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/sreeks1812/Extended-attributes-support-for--wrapfs--stackable-file-system> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/da-x-ace/System-Call-Inherit> <https://schema.org/name> "da-x-ace/System-Call-Inherit"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/vamsi44> <https://schema.org/author> <https://github.com/vamsi44/Extended-Address-Space-Operations-Support-for--WRAPFS--File-System> .
<https://github.com/fanyang88/scraper> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/ChatApp--p2p> <https://schema.org/dateModified> "2015-10-21T21:53:34"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/SBU-OS-proj> <https://schema.org/identifier> "33745914"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/omsanket/SB_SHELL> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/da-x-ace> <https://schema.org/author> <https://github.com/da-x-ace/System-Call-Inherit> .
<https://github.com/omsanket> <https://schema.org/image> <https://avatars3.githubusercontent.com/u/11070748?v=4> .
<https://github.com/omsanket/SB_SHELL> <https://schema.org/identifier> "31394969"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/SOYJUN/TCP-socket-client-server> <https://schema.org/description> "The aim of this assignment is to have you do TCP socket client / server programming using I/O multiplexing, child processes and threads. It also aims at getting you to familiarize yourselves with the inetd superserver daemon, the \u2018exec\u2019 family of functions, various socket error scenarios, some socket options, and some basic domain name / IP address conversion functions. Apart from the material in Chapters 1 to 6 covered in class, you will also need to refer to the following :  the exec family of functions (Section 4.7 of Chapter 4)  using pipes for interprocess communication (IPC) in Unix  error scenarios induced by process terminations & host crashes (Sections 5.11 to 5.16, Chapter 5)  setsockopt function & SO_REUSEADDR socket option (Section 7.2 & pp.210-213, Chapter 7)  gethostbyname & gethostbyaddr functions (Sections 11.3 & 11.4, Chapter 11)  the basic structure of inetd (Section 13.5, Chapter 13)  programming with threads (Sections 26.1 to 26.5, Chapter 26) Overview  I shall present an overview of this assignment and discuss some of the specification details given below in class on Wednesday, September 17 & Monday, September 22.  Client  The client is evoked with a command line argument giving either the server IP address in dotted decimal notation, or the server domain name. The client has to be able to handle either mode and figure out which of the two is being passed to it. If it is given the IP address, it calls the gethostbyaddr function to get the domain name, which it then prints out to the user in the form of an appropriate message (e.g., \u2018The server host is compserv1.cs.stonybrook.edu\u2019). The function gethostbyname, on the other hand, returns the IP address that corresponds to a given domain name. The client then enters an infinite loop in which it queries the user which service is being requested. There are two options : echo and time (note that time is a slightly modified version of the daytime service \u2013 see below). The client then forks off a child. After the child is forked off, the parent process enters a second loop in which it continually reads and prints out status messages received from the child via a half-duplex pipe (see below). The parent exits the second loop when the child closes the pipe (how does the parent detect this?), and/or the SIGCHLD signal is generated when the child terminates. The parent then repeats the outer loop, querying the user again for the (next) service s/he desires. This cycle continues till the user responds to a query with quit rather than echo or time.  The child process is the one which handles the actual service for the user. It execs (see Section 4.7, Chapter 4) an xterm to generate a separate window through which all interactions with server and user take place. For example, the following exec function call evokes an xterm, and gets the xterm to execute echocli, located in the current directory, passing the string 127.0.0.1 (assumed to be the IP address of the server) as the command line argument argv[1] to echocli (click on the url for further details) :  execlp(\"xterm\", \"xterm\", \"-e\", \"./echocli\", \"127.0.0.1\", (char *) 0)  xterm executes one of two client programs (echocli or timecli, say) depending on the service requested. A client program establishes a TCP connection to the server at the \u2018well-known port\u2019 for the service (in reality, this port will, of course, be some ephemeral port of your choosing, the value of which is known to both server and client code). All interaction with the user, on the one hand, and with the server, on the other, takes place through the child\u2019s xterm window, not the parent\u2019s window. On the other hand, the child will use a half-duplex pipe to relay status information to the parent which the parent prints out in its window (see below).To terminate the echo client, the user can type in ^D (CTRL D, the EOF character). To terminate the time client, the only option is for the user to type in ^C (CTRL C). (This can also be used as an alternative means of terminating the echo client.) Note that using ^C in the context of the time service will give the server process the impression that the client process has \u2018crashed\u2019. It is your responsibility to ensure that the server process handles this correctly and closes cleanly. I shall address this further when discussing the server process.  It is also part of your responsibility in this assignment to ensure that the client code is robust with respect to the server process crashing (see Sections 5.12 & 5.13, Chapter 5). Amongst other implications, this means that it would probably be a good idea for you to implement your echo client code along the lines of either : Figure 6.9, p.168 (or even Figure 6.13, p.174) which uses I/O multiplexing with the select function; or of Figure 26.2, p.680, which uses threads; rather than along the lines of Figure 5.5, p.125.  When the child terminates, either normally or abnormally, its xterm window disappears instantaneously. Consequently, any status information that the child might want to communicate to the user should not be printed out on the child\u2019s xterm window, since the user will not have time to see the final such message before the window disappears. Instead, as the parent forks off the child at the beginning, a half-duplex pipe should be established from child to parent. The child uses the pipe to send status reports to the parent, which the parent prints out in its window. I leave it up to you to decide what status information exactly should be relayed to the parent but, at a minimum, the parent should certainly be notified, in as precise terms as possible, of any abnormal termination conditions of the service provided by the child.  In general, you should try to make your code as robust as possible with respect to handling errors, including confused behaviour by the user (e.g., passing an invalid command line argument; responding to a query incorrectly; trying to interact with the service through the parent process window, not the child process xterm; etc.). Amongst other things, you have to worry about EINTR errors occurring during slow system calls (such as the parent reading from the pipe, or, possibly, printing to stdout, for example) due to a SIGCHLD signal. What about other kinds of errors? Which ones can occur? How should you handle them?  Server  The server has to be able to handle multiple clients using threads (specifically, detached threads), not child processes (see Sections 26.1 to 26.4, Chapter 26). Furthermore, it has to be able to handle multiple types of service; in our case, two : echo and time. echo is just the standard echo service we have seen in class. time is a slightly modified version of the daytime service (see Figure 1.9, p.14) : instead of sending the client the \u2018daytime\u2019 just once and closing, the service sits in an infinite loop, sending the \u2018daytime\u2019, sleeping for 5 seconds, and repeating, ad infinitum.  The server is loosely based on the way the inetd daemon works : see Figure 13.7, p.374. However, note that the differences between inetd and our server are probably more significant than the similarities: inetd forks off children, whereas our server uses threads; inetd child processes issue exec commands, which our server threads do not; etc. So you should treat Figure 13.7 (and Section 13.5, Chapter 13, generally) as a source of ideas, not as a set of specifications which you must slavishly adhere to and copy. Note, by the way, that there are some similarities between our client and inetd (primarily, forking off children which issue execs), which could be a useful source of ideas.  The server creates a listening socket for each type of service that it handles, bound to the \u2018well-known port\u2019 for that service. It then uses select to await clients (Chapter 6; or, if you prefer, poll; note that pselect is not supported in Solaris 2.10). The socket on which a client connects identifies the service the client is seeking. The server accepts the connection and creates a thread which provides the service. The thread detaches itself. Meanwhile, the main thread goes back to the select to await further clients.  A major concern when using threads is to make sure that operations are thread safe (see p.685 and on into Section 26.5). In this respect, Stevens\u2019 readline function (in Stevens\u2019 file unpv13e/lib/readline.c, see Figure 3.18, pp.91-92) poses a particular problem. On p.686, the authors give three options for dealing with this. The third option is too inefficient and should be discarded. You can implement the second option if you wish. Easiest of all would be the first option, since it involves using a thread-safe version of readline (see Figures 26.11 & 26.12) provided in file unpv13e/threads/readline.c. Whatever you do, remember that Stevens\u2019 library, libunp.a, contains the non-thread-safe version of Figure 3.18, and that is the version that will be link-loaded to your code unless you undertake explicit steps to ensure this does not happen (libunp.a also contains the \u2018wrapper\u2019 function Readline, whose code is also in file unpv13e/lib/readline.c). Remaking your copy of libunp.a with the \u2018correct\u2019 version of readline is not a viable option because when you hand in your code, it will be compiled and link-loaded with respect to the version of libunp.a in the course account, ~cse533/Stevens/unpv13e_solaris2.10 (I do not intend to change that version since it risks creating confusion later on in the course). Also, you will probably want to use the original version of readline in the client code anyway. I am providing you with a sample Makefile which picks up the thread-safe version of readline from directory ~cse533/Stevens/unpv13e_solaris2.10/threads and uses it when making the executable for the server, but leaves the other executables it makes to link-load the non-thread-safe version from libunp.a.  Again, it is part of your responsibility to make sure that your server code is as robust as possible with respect to errors, and that the server threads terminate cleanly under all circumstances. Recall, first of all, that the client user will often use ^C (CTRL C) in the xterm to terminate the service. This will appear to the server thread as if the client process has crashed. You need to think about the error conditions that will be induced (see Sections 5.11 to 5.13, Chapter 5), and how the echo and time server code is to detect and handle these conditions. For example, the time server will almost certainly experience an EPIPE error (see Section 5.13). How should the associated SIGPIPE signal be handled? Be aware that when we return out of the Stevens\u2019 writen function with -1 (indicating an error) and check errno, errno is sometimes equal to 0, not EPIPE (value 32). This can happen under Solaris 2.10, but I am not sure under precisely what conditions nor why. Nor am I sure if it also happens under other Unix versions, or if it also happens when using write rather than writen. The point is, you cannot depend on errno to find out what has happened to the write or writen functions. My suggestion, therefore, is that the time server should use the select function. On the one hand, select\u2019s timeout mechanism can be used to make the server sleep for the 5 seconds. On the other hand, select should also monitor the connection socket read event because, when the client xterm is ^C\u2019ed, a FIN will be sent to the server TCP, which will prime the socket for reading; a read on the socket will then return with value 0 (see Figure 14.3, p. 385 as an example).  But what about errors other than EPIPE? Which ones can occur? How should you handle them? Recall, as well, that if a thread terminates without explicitly closing the connection socket it has been using, the connection socket will remain existent until the server process itself dies (why?). Since the server process is supposed, in principle, to run for ever, you risk ending up with an ever increasing number of unused, \u2018orphaned\u2019 sockets unless you are careful.  Whenever a server thread detects the termination of its client, it should print out a message giving appropriate details: e.g., \u201CClient termination: EPIPE error detected\u201D, \u201CClient termination: socket read returned with value 0\u201D, \u201CClient termination: socket read returned with value -1, errno = . . .\u201D, and so on.  When debugging your server code, you will probably find that restarting the server very shortly after it was last running will give you trouble when it comes to bind to its \u2018well-known ports\u2019. This is because, when the server side initiates connection termination (which is what will happen if the server process crashes; or if you kill it first, before killing the client) TCP keeps the connections open in the TIME_WAIT state for 2MSLs (Sections 2.6 & 2.7, Chapter 2). This could very quickly become a major irritant. I suggest you explore the possibility of using the SO_REUSEADDR socket option (pp.210-213, Chapter 7; note that the SO_REUSEPORT socket option is not supported in Solaris 2.10), which should help keep the stress level down. You will need to use the setsockopt function (Section 7.2) to enable this option. Figure 8.24, p.263, shows an instance of server code that sets the SO_REUSEADDR socket option.  Finally, you should be aware of the sort of problem, described in Section 16.6, pp.461-463, that might occur when (blocking) listening sockets are monitored using select. Such sockets should be made nonblocking, which requires use of the fcntl  function after socket creates the socket, but before listen turns the socket into a listening socket."^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/sreeks1812> <https://schema.org/contributor> <https://github.com/sreeks1812/On-Demand-Distance-Vector-Routing-for-networks-of-arbitrary-and-unknown-connectivity> .
<https://github.com/sreeks1812/system-call-to-check-integrity-of-a-file> <https://schema.org/identifier> "12794804"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/kakus5> <https://schema.org/BookmarkAction> <https://github.com/SOYJUN/Implement-ODR-protocol> .
<https://github.com/sreeks1812/Adding-reliability-to-UDP> <https://schema.org/name> "sreeks1812/Adding-reliability-to-UDP"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN/threadPool-POXIS-thread> <https://schema.org/name> "SOYJUN/threadPool-POXIS-thread"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/da-x-ace/Address-Space-ops-in-Wrapfs> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/fanyang88/particle-system> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/SOYJUN> <https://schema.org/name> "JUN ZENG"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/phpone> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/da-x-ace/SuperComputing-HW3> <https://schema.org/dateModified> "2014-05-05T16:40:09"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/sreeks1812/On-Demand-Distance-Vector-Routing-for-networks-of-arbitrary-and-unknown-connectivity> <https://schema.org/dateCreated> "2013-09-15T02:23:15"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/sreeks1812/Adding-reliability-to-UDP> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/sreeks1812/system-call-to-check-integrity-of-a-file> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/omsanket/SB_SHELL> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/da-x-ace/openSSL-compatible-RSA-Engine> <https://schema.org/codeRepository> <https://github.com/da-x-ace/openSSL-compatible-RSA-Engine> .
<https://github.com/da-x-ace/Boruvka-GPGPU> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/SOYJUN/C-Thread-Pool> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/fanyang88/face-tracking> <https://schema.org/dateCreated> "2012-04-22T15:12:48"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/sreeks1812/Extended-attributes-support-for--wrapfs--stackable-file-system> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/fanyang88/leetcode-in-js> <https://schema.org/dateCreated> "2018-08-23T22:17:36"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/da-x-ace/SuperComputing-HW3> <https://schema.org/dateCreated> "2013-01-31T01:02:27"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/da-x-ace/Authorship-Attribution> <https://schema.org/dateCreated> "2013-01-31T02:33:06"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/da-x-ace/openSSL-compatible-RSA-Engine> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/da-x-ace> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/omsanket/CourseraTest> <https://schema.org/identifier> "59620840"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/omsanket/PreemptiveOS> <https://schema.org/name> "omsanket/PreemptiveOS"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/arpitsardhana/ODR-on-local-LAN> <https://schema.org/name> "arpitsardhana/ODR-on-local-LAN"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/face-tracking> <https://schema.org/dateModified> "2015-06-25T10:33:09"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/sreeks1812/On-Demand-Distance-Vector-Routing-for-networks-of-arbitrary-and-unknown-connectivity> <https://schema.org/identifier> "12839301"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/vamsi44/File-Transfer-Protocol> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/fanyang88> <https://schema.org/author> <https://github.com/fanyang88/algorithms> .
<https://github.com/da-x-ace/Reliable-UDP> <https://schema.org/codeRepository> <https://github.com/da-x-ace/Reliable-UDP> .
<https://github.com/da-x-ace/Authorship-Attribution> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/sreeks1812/Script-Nonce-Module-for-Apache> <https://schema.org/description> "Designed and implemented an Apache module to automatically insert script nonces into web pages served by Apache. The module is configured to look for scripts with \u201Csome secret value\u201D and replace it with a fresh random SHA-1 value that is also placed in the CSP response header. This helps in preventing XSS attacks."^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/jorgemachucav> <https://schema.org/image> <https://avatars3.githubusercontent.com/u/47221983?v=4> .
<https://github.com/sreeks1812/system-call-to-check-integrity-of-a-file> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/fanyang88/JSON-java> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/fanyang88/Roman_Numeral_converter> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/omsanket/TCP-socket-server-client-C-programming> <https://schema.org/name> "omsanket/TCP-socket-server-client-C-programming"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/distributed-algorithm_Agarwal-El-Abbadi> <https://schema.org/dateCreated> "2012-12-29T01:07:30"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/threadpool-1> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/da-x-ace/System-Call-Inherit> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/da-x-ace/Address-Space-ops-in-Wrapfs> <https://schema.org/identifier> "7928747"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/da-x-ace/Shared-and-Distributed-Memory-Randomized-Quick-Sort> <https://schema.org/description> "Used cilk++ for Shared memory parallelism, and MPI for distributed memory paralellism"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/omsanket> <https://schema.org/author> <https://github.com/omsanket/BettingApp> .
<https://github.com/da-x-ace/openSSL-compatible-RSA-Engine> <https://schema.org/dateCreated> "2013-01-31T02:41:12"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SuriyaaKudoIsc> <https://schema.org/identifier> "5073946"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/fanyang88/algorithms> <https://schema.org/codeRepository> <https://github.com/fanyang88/algorithms> .
<https://github.com/fanyang88/friendface> <https://schema.org/name> "fanyang88/friendface"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/omsanket/Implementation-of-ODR-protocol-using-C-language> <https://schema.org/codeRepository> <https://github.com/omsanket/Implementation-of-ODR-protocol-using-C-language> .
<https://github.com/sreeks1812/system-call-to-check-integrity-of-a-file> <https://schema.org/codeRepository> <https://github.com/sreeks1812/system-call-to-check-integrity-of-a-file> .
<https://github.com/omsanket> <https://schema.org/name> "Sanket Sharma"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN/TCP-socket-client-server> <https://schema.org/dateModified> "2019-01-10T05:50:25"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/scraper> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/fanyang88/ARP_protocol> <https://schema.org/dateModified> "2013-11-26T12:50:13"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/friendface> <https://schema.org/dateModified> "2013-10-04T04:38:04"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/practise> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/SOYJUN> <https://schema.org/author> <https://github.com/SOYJUN/SBUshell> .
<https://github.com/sreeks1812/On-Demand-Distance-Vector-Routing-for-networks-of-arbitrary-and-unknown-connectivity> <https://schema.org/name> "sreeks1812/On-Demand-Distance-Vector-Routing-for-networks-of-arbitrary-and-unknown-connectivity"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/sreeks1812/On-Demand-Distance-Vector-Routing-for-networks-of-arbitrary-and-unknown-connectivity> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/fanyang88> <https://schema.org/author> <https://github.com/fanyang88/Tic_Tac_Toe> .
<https://github.com/SOYJUN> <https://schema.org/author> <https://github.com/SOYJUN/threadPool-POXIS-thread> .
<https://github.com/fanyang88/scraper> <https://schema.org/dateModified> "2018-12-20T21:34:00"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/ChatApp--p2p> <https://schema.org/identifier> "44705156"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/sreeks1812/Script-Nonce-Module-for-Apache> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/vamsi44/System-Call-for-checking-the-integrity-of-files> <https://schema.org/dateCreated> "2013-09-15T02:12:56"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/vamsi44/File-Transfer-Protocol> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/vamsi44> <https://schema.org/author> <https://github.com/vamsi44/File-Transfer-Protocol> .
<https://github.com/da-x-ace/openSSL-compatible-RSA-Engine> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/sreeks1812/On-Demand-Distance-Vector-Routing-for-networks-of-arbitrary-and-unknown-connectivity> <https://schema.org/description> "Implemented On-demand Routing (ODR) protocol, a simplified version of the AODV protocol, using OSI Layer 2 sockets (PF_PACKET) and UNIX domain sockets in a simulated virtual environment. Designed Client and Server applications that use UNIX domain sockets to communicate with underlying ODR in order to exchange messages between them."^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/omsanket/TCP-socket-server-client-C-programming> <https://schema.org/dateModified> "2015-02-19T06:59:27"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/da-x-ace/Boruvka-GPGPU> <https://schema.org/codeRepository> <https://github.com/da-x-ace/Boruvka-GPGPU> .
<https://github.com/da-x-ace/Misc> <https://schema.org/dateModified> "2014-04-13T11:05:07"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/leetcode-in-js> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/sreeks1812> <https://schema.org/image> <https://avatars2.githubusercontent.com/u/5447379?v=4> .
<https://github.com/omsanket/CourseraTest> <https://schema.org/name> "omsanket/CourseraTest"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/ChatApp--p2p> <https://schema.org/codeRepository> <https://github.com/fanyang88/ChatApp--p2p> .
<https://github.com/fanyang88/JSON-java> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q251> .
<https://github.com/sreeks1812/Extended-attributes-support-for--wrapfs--stackable-file-system> <https://schema.org/codeRepository> <https://github.com/sreeks1812/Extended-attributes-support-for--wrapfs--stackable-file-system> .
<https://github.com/da-x-ace/Misc> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/omsanket/CourseraTest> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/SOYJUN/threadPool-POXIS-thread> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/fanyang88/reliable_UDP> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/vamsi44/System-Call-for-checking-the-integrity-of-files> <https://schema.org/dateModified> "2018-06-12T06:22:49"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/vamsi44/File-Transfer-Protocol> <https://schema.org/dateCreated> "2013-09-15T02:08:38"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/da-x-ace/Shared-and-Distributed-Memory-Randomized-Quick-Sort> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q2407> .
<https://github.com/omsanket> <https://schema.org/contributor> <https://github.com/omsanket/Implementation-of-ODR-protocol-using-C-language> .
<https://github.com/fanyang88/distributed-algorithm-implementation-maekawa-s-algorithm> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/fanyang88/Roman_Numeral_converter> <https://schema.org/codeRepository> <https://github.com/fanyang88/Roman_Numeral_converter> .
<https://github.com/omsanket/BettingApp> <https://schema.org/codeRepository> <https://github.com/omsanket/BettingApp> .
<https://github.com/da-x-ace/Reliable-UDP> <https://schema.org/dateModified> "2019-03-04T16:50:19"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/SBU-OS-proj> <https://schema.org/name> "SOYJUN/SBU-OS-proj"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/omsanket/TCP-socket-server-client-C-programming> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/ARP_protocol> <https://schema.org/dateCreated> "2012-12-29T00:12:13"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN> <https://schema.org/author> <https://github.com/SOYJUN/SBU-OS-proj> .
<https://github.com/arpitsardhana> <https://schema.org/identifier> "9325553"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/fanyang88/friendface> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/omsanket/BettingApp> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN/aws-sdk-ruby> <https://schema.org/identifier> "104275954"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/SOYJUN/SBUshell> <https://schema.org/description> " Support changing current directory ( cd ) Execute binaries interactively Execute scripts Execute pipelines of binaries ( /bin/ls | /bin/grep test ) Set and use PATH and PS1 variables  Provide all functionality needed by your sbush Implement all functions from include/stdlib.h Rely on 64-bit Linux syscall numbers and conventions "^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/ODR_protocol_implementation> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/omsanket/SB_SHELL> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/jorgemachucav> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/SOYJUN/aws-sdk-ruby> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q161053> .
<https://github.com/omsanket/BettingApp> <https://schema.org/dateCreated> "2016-06-06T19:17:29"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN> <https://schema.org/author> <https://github.com/SOYJUN/Implement-ODR-protocol> .
<https://github.com/vamsi44/On-Demand-Shortest-Hop-Routing> <https://schema.org/identifier> "12839077"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/fanyang88/ChatApp--p2p> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q2005> .
<https://github.com/fanyang88/leetcode-in-js> <https://schema.org/identifier> "145912895"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/SOYJUN> <https://schema.org/image> <https://avatars1.githubusercontent.com/u/8823580?v=4> .
<https://github.com/omsanket/FTP-using-UDP-socket-server-client-C-programming> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/fanyang88/distributed-algorithm-implementation-maekawa-s-algorithm> <https://schema.org/dateCreated> "2012-12-29T00:42:15"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/C-Thread-Pool> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/fanyang88/ARP_protocol> <https://schema.org/codeRepository> <https://github.com/fanyang88/ARP_protocol> .
<https://github.com/vamsi44/System-Call-for-checking-the-integrity-of-files> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/SOYJUN/C-Thread-Pool> <https://schema.org/identifier> "46145894"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/SOYJUN/threadpool-1> <https://schema.org/name> "SOYJUN/threadpool-1"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/3D_triangulation> <https://schema.org/identifier> "7362174"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/vamsi44/Content-Security-Policy-Script-Nonce-Filter-for-Apache> <https://schema.org/identifier> "12839200"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/fanyang88> <https://schema.org/name> "Fan Yang"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/omsanket/FTP-using-UDP-socket-server-client-C-programming> <https://schema.org/codeRepository> <https://github.com/omsanket/FTP-using-UDP-socket-server-client-C-programming> .
<https://github.com/sreeks1812/Script-Nonce-Module-for-Apache> <https://schema.org/identifier> "12839394"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/SOYJUN/FTP-implement-based-on-UDP> <https://schema.org/name> "SOYJUN/FTP-implement-based-on-UDP"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN/SBUshell> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/fanyang88> <https://www.wikidata.org/wiki/Property:P3919> <https://github.com/fanyang88/ODR_protocol_implementation> .
<https://github.com/da-x-ace/Misc> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/fanyang88/distributed-algorithm-implementation-maekawa-s-algorithm> <https://schema.org/identifier> "7361509"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/SOYJUN/registerSys> <https://schema.org/identifier> "45063084"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/sreeks1812> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20204892> .
<https://github.com/fanyang88/ChatApp--p2p> <https://schema.org/description> "used nodejs express socket.io created a chatApp (p2p mode)"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/sreeks1812> <https://schema.org/author> <https://github.com/sreeks1812/Adding-reliability-to-UDP> .
<https://github.com/da-x-ace/On-Demand-Routing> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/da-x-ace/Address-Space-ops-in-Wrapfs> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/arpitsardhana/ODR-on-local-LAN> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/da-x-ace/Reliable-UDP> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/fanyang88/reliable_UDP> <https://schema.org/identifier> "7361459"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/omsanket/TCP-socket-server-client-C-programming> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/omsanket/-Tour-Application-using-C-language> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/fanyang88/Distributed-algorithm-Majority-voting> <https://schema.org/name> "fanyang88/Distributed-algorithm-Majority-voting"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88> <https://schema.org/author> <https://github.com/fanyang88/ODR_protocol_implementation> .
<https://github.com/da-x-ace/On-Demand-Routing> <https://schema.org/codeRepository> <https://github.com/da-x-ace/On-Demand-Routing> .
<https://github.com/SOYJUN> <https://schema.org/author> <https://github.com/SOYJUN/TCP-socket-client-server> .
<https://github.com/SOYJUN> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/SOYJUN/aws-sdk-ruby> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/sreeks1812/Address-space-operations-support-for--wrapfs--stackable-file-system> <https://schema.org/name> "sreeks1812/Address-space-operations-support-for--wrapfs--stackable-file-system"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/vamsi44> <https://schema.org/author> <https://github.com/vamsi44/On-Demand-Shortest-Hop-Routing> .
<https://github.com/SOYJUN/TCP-socket-client-server> <https://schema.org/codeRepository> <https://github.com/SOYJUN/TCP-socket-client-server> .
<https://github.com/fanyang88/leetcode_java> <https://schema.org/codeRepository> <https://github.com/fanyang88/leetcode_java> .
<https://github.com/fanyang88/particle-system> <https://schema.org/identifier> "4105073"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/omsanket/-Tour-Application-using-C-language> <https://schema.org/codeRepository> <https://github.com/omsanket/-Tour-Application-using-C-language> .
<https://github.com/da-x-ace/SuperComputing-HW3> <https://schema.org/codeRepository> <https://github.com/da-x-ace/SuperComputing-HW3> .
<https://github.com/omsanket/-Tour-Application-using-C-language> <https://schema.org/dateCreated> "2015-02-19T07:28:26"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/omsanket/CourseraTest> <https://schema.org/dateModified> "2016-05-25T01:26:37"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/practise> <https://schema.org/dateModified> "2018-05-17T21:02:43"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/chatRoom> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/da-x-ace/multicast-tour-application> <https://schema.org/name> "da-x-ace/multicast-tour-application"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/Distributed-algorithm-Majority-voting> <https://schema.org/dateModified> "2013-01-13T20:59:42"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/XMLParser> <https://schema.org/name> "SOYJUN/XMLParser"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/omsanket/-Tour-Application-using-C-language> <https://schema.org/dateModified> "2015-02-19T07:32:59"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/da-x-ace/Android_Project_Yamba_Client> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/vamsi44/On-Demand-Shortest-Hop-Routing> <https://schema.org/dateModified> "2013-10-23T16:10:56"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88> <https://schema.org/author> <https://github.com/fanyang88/friendface> .
<https://github.com/SOYJUN/Application-with-raw-IP-sockets> <https://schema.org/codeRepository> <https://github.com/SOYJUN/Application-with-raw-IP-sockets> .
<https://github.com/SOYJUN/XMLParser> <https://schema.org/codeRepository> <https://github.com/SOYJUN/XMLParser> .
<https://github.com/fanyang88/distributed-algorithm_Agarwal-El-Abbadi> <https://schema.org/name> "fanyang88/distributed-algorithm_Agarwal-El-Abbadi"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/sreeks1812/system-call-to-check-integrity-of-a-file> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/SOYJUN/C-Thread-Pool> <https://schema.org/dateModified> "2015-11-13T20:36:07"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <https://schema.org/dateModified> "2019-02-24T08:27:06"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/da-x-ace/Android_Project_Yamba_Client> <https://schema.org/dateModified> "2014-08-20T16:49:13"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/Distributed-algorithm-Majority-voting> <https://schema.org/codeRepository> <https://github.com/fanyang88/Distributed-algorithm-Majority-voting> .
<https://github.com/vamsi44/System-Call-for-checking-the-integrity-of-files> <https://schema.org/codeRepository> <https://github.com/vamsi44/System-Call-for-checking-the-integrity-of-files> .
<https://github.com/da-x-ace/openSSL-compatible-RSA-Engine> <https://schema.org/name> "da-x-ace/openSSL-compatible-RSA-Engine"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/algorithms> <https://schema.org/dateCreated> "2018-08-23T22:22:50"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/Application-with-raw-IP-sockets> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/SOYJUN/aws-sdk-ruby> <https://schema.org/dateCreated> "2017-09-20T22:57:50"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/XMLParser> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/sreeks1812/Address-space-operations-support-for--wrapfs--stackable-file-system> <https://schema.org/dateCreated> "2013-09-15T02:31:13"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/da-x-ace/Reliable-UDP> <https://schema.org/name> "da-x-ace/Reliable-UDP"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN/SBU-OS-proj> <https://schema.org/dateCreated> "2015-04-10T19:09:12"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/da-x-ace/Reliable-UDP> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/fanyang88/distributed-algorithm-implementation-maekawa-s-algorithm> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/vamsi44/On-Demand-Shortest-Hop-Routing> <https://schema.org/description> "Developed and Implemented an On-Demand Shortest-Hop Routing (ODR) protocol for networks of fixed but arbitrary and unknown connectivity, using PF_PACKET sockets. The implementation is based on the AODV algorithm. Implemented an API using Unix domain datagram sockets that enables applications to communicate with the ODR mechanism running locally at their nodes."^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/da-x-ace/Address-Space-ops-in-Wrapfs> <https://schema.org/codeRepository> <https://github.com/da-x-ace/Address-Space-ops-in-Wrapfs> .
<https://github.com/sreeks1812/Adding-reliability-to-UDP> <https://schema.org/identifier> "12839254"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/fanyang88/distributed-algorithm_Agarwal-El-Abbadi> <https://schema.org/identifier> "7361654"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/da-x-ace/SuperComputing-HW3> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88> <https://schema.org/author> <https://github.com/fanyang88/leetcode_java> .
<https://github.com/fanyang88/scraper> <https://schema.org/name> "fanyang88/scraper"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/omsanket/TCP-socket-server-client-C-programming> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/sreeks1812/Address-space-operations-support-for--wrapfs--stackable-file-system> <https://schema.org/description> "Modified wrapfs stackable file system to implement address space operations that support different data pages at the upper and lower layers. Added a mount-time option that gives the flexibility to choose between address space operations and the default behavior which is a single page fault operation. Implemented data page encryption at the lower layer that demonstrates support for the address-space operations."^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/vamsi44> <https://schema.org/name> "Vamsi Varanasi"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/sreeks1812/Extended-attributes-support-for--wrapfs--stackable-file-system> <https://schema.org/description> "Modified wrapfs open-source stackable file system to support two Extended attributes (EAs) to tell the user if a file has integrity or not and to compute the integrity value of a file respectively. Extended the EA to support directory inodes."^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/vamsi44/Extended-Integrity-Support-for--WRAPFS--File-System> <https://schema.org/description> "Implemented Extended Attributes (xattr) support for wrapfs stackable file system (Linux 3.2) and added two extended attributes to the file system. The extended attribute \u201Chas_integrity\u201D specifies to user if the integrity for a file exists or not. The \u201Cintegrity_val\u201D extended attribute computes and stores the MD5 checksum for the file. Extended the \u201Chas_integrity\u201D attribute support to the directory inodes."^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/phpone> <https://schema.org/dateCreated> "2012-11-05T04:18:23"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <https://schema.org/dateCreated> "2015-04-10T18:49:12"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/Distributed-algorithm-Majority-voting> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/fanyang88/leetcode_java> <https://schema.org/dateCreated> "2019-01-02T18:53:31"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/vamsi44/Extended-Address-Space-Operations-Support-for--WRAPFS--File-System> <https://schema.org/description> "Implemented address space operations on wrapfs stackable file system (Linux 3.2) to support different data pages at lower and upper layers of file system. Implemented data page encryption at the lower layer which denotes the support for the address-space operations."^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/da-x-ace> <https://schema.org/identifier> "3432910"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/fanyang88/Roman_Numeral_converter> <https://schema.org/dateCreated> "2012-12-29T02:34:24"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/da-x-ace> <https://schema.org/author> <https://github.com/da-x-ace/xcrypt-system-call> .
<https://github.com/SOYJUN/registerSys> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/omsanket/-Tour-Application-using-C-language> <https://schema.org/identifier> "31005397"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/fanyang88/ChatApp--p2p> <https://schema.org/dateCreated> "2015-10-21T21:18:52"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/registerSys> <https://schema.org/name> "SOYJUN/registerSys"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/omsanket/FTP-using-UDP-socket-server-client-C-programming> <https://schema.org/name> "omsanket/FTP-using-UDP-socket-server-client-C-programming"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/distributed-algorithm-implementation-maekawa-s-algorithm> <https://schema.org/codeRepository> <https://github.com/fanyang88/distributed-algorithm-implementation-maekawa-s-algorithm> .
<https://github.com/sreeks1812/Script-Nonce-Module-for-Apache> <https://schema.org/codeRepository> <https://github.com/sreeks1812/Script-Nonce-Module-for-Apache> .
<https://github.com/vamsi44/On-Demand-Shortest-Hop-Routing> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/fanyang88/distributed-algorithm_Agarwal-El-Abbadi> <https://schema.org/dateModified> "2013-01-13T20:59:42"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/vamsi44/File-Transfer-Protocol> <https://schema.org/codeRepository> <https://github.com/vamsi44/File-Transfer-Protocol> .
<https://github.com/da-x-ace/Authorship-Attribution> <https://schema.org/dateModified> "2013-11-26T18:48:00"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/omsanket> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/SOYJUN/TCP-socket-client-server> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/fanyang88/3D_triangulation> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/phpone> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/fanyang88/leetcode-in-js> <https://schema.org/codeRepository> <https://github.com/fanyang88/leetcode-in-js> .
<https://github.com/fanyang88> <https://schema.org/image> <https://avatars0.githubusercontent.com/u/1666725?v=4> .
<https://github.com/arpitsardhana/ODR-on-local-LAN> <https://schema.org/identifier> "49160161"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/da-x-ace/Android_Project_Yamba_Client> <https://schema.org/codeRepository> <https://github.com/da-x-ace/Android_Project_Yamba_Client> .
<https://github.com/fanyang88/leetcode_java> <https://schema.org/dateModified> "2019-03-29T23:20:54"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/algorithms> <https://schema.org/description> "leetcode"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN/chatRoom> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q2407> .
<https://github.com/omsanket/BettingApp> <https://schema.org/name> "omsanket/BettingApp"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/da-x-ace/Reliable-UDP> <https://schema.org/description> "Added TCP reliability features over UDP. Implemented slow start, congestion avoidance, flow-control, fast retransmit and fast recovery mechanisms. "^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/vamsi44/Content-Security-Policy-Script-Nonce-Filter-for-Apache> <https://schema.org/description> "Designed and Implemented Content Security Policy(CSP) script nonce feature as an Apache Module, to prevent cross-site scripting attacks (XSS). The module is configured to automatically look for the scripts with a server specific script nonce value and replaces it with a fresh random SHA-1 value that is also placed in CSP header."^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/ARP_protocol> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/particle-system> <https://schema.org/codeRepository> <https://github.com/fanyang88/particle-system> .
<https://github.com/fanyang88/friendface> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://www.wikidata.org/wiki/Property:P1324> <http://www.w3.org/2002/07/owl#sameAs> <https://schema.org/SoftwareSourceCode> .
<https://github.com/da-x-ace/Boruvka-GPGPU> <https://schema.org/description> "Boruvka Algorithm Implementation on GPGPU"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/da-x-ace/SuperComputing-HW3> <https://schema.org/name> "da-x-ace/SuperComputing-HW3"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/omsanket/BettingApp> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/da-x-ace/multicast-tour-application> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/SOYJUN> <https://schema.org/identifier> "8823580"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/fanyang88/scraper> <https://schema.org/identifier> "162633557"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/sreeks1812/On-Demand-Distance-Vector-Routing-for-networks-of-arbitrary-and-unknown-connectivity> <https://schema.org/dateModified> "2013-09-24T04:56:13"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/da-x-ace/xcrypt-system-call> <https://schema.org/dateCreated> "2013-01-31T02:53:19"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/omsanket/SB_SHELL> <https://schema.org/name> "omsanket/SB_SHELL"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/omsanket/SB_SHELL> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/da-x-ace/Boruvka-GPGPU> <https://schema.org/dateModified> "2013-12-04T13:06:18"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/leetcode_java> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q251> .
<https://github.com/da-x-ace/multicast-tour-application> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/fanyang88> <https://schema.org/author> <https://github.com/fanyang88/reliable_UDP> .
<https://github.com/da-x-ace/Android_Project_Yamba_Client> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/omsanket/-Tour-Application-using-C-language> <https://schema.org/name> "omsanket/-Tour-Application-using-C-language"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/vamsi44/Content-Security-Policy-Script-Nonce-Filter-for-Apache> <https://schema.org/dateCreated> "2013-09-15T02:13:56"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/FTP-implement-based-on-UDP> <https://schema.org/codeRepository> <https://github.com/SOYJUN/FTP-implement-based-on-UDP> .
<https://github.com/fanyang88> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/omsanket/CourseraTest> <https://schema.org/codeRepository> <https://github.com/omsanket/CourseraTest> .
<https://github.com/vamsi44/Extended-Address-Space-Operations-Support-for--WRAPFS--File-System> <https://schema.org/identifier> "12839176"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/sreeks1812> <https://www.wikidata.org/wiki/Property:P3919> <https://github.com/sreeks1812/On-Demand-Distance-Vector-Routing-for-networks-of-arbitrary-and-unknown-connectivity> .
<https://github.com/SOYJUN> <https://schema.org/author> <https://github.com/SOYJUN/Application-with-raw-IP-sockets> .
<https://github.com/SOYJUN> <https://schema.org/author> <https://github.com/SOYJUN/XMLParser> .
<https://github.com/omsanket/SB_SHELL> <https://schema.org/codeRepository> <https://github.com/omsanket/SB_SHELL> .
<https://github.com/da-x-ace/openSSL-compatible-RSA-Engine> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/arpitsardhana> <https://schema.org/author> <https://github.com/arpitsardhana/ODR-on-local-LAN> .
<https://github.com/sreeks1812/Adding-reliability-to-UDP> <https://schema.org/dateCreated> "2013-09-15T02:18:13"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/aws-sdk-ruby> <https://schema.org/dateModified> "2017-09-20T22:58:01"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/omsanket/Implementation-of-ODR-protocol-using-C-language> <https://schema.org/name> "omsanket/Implementation-of-ODR-protocol-using-C-language"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/sreeks1812/Address-space-operations-support-for--wrapfs--stackable-file-system> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/vamsi44/On-Demand-Shortest-Hop-Routing> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/fanyang88/ARP_protocol> <https://schema.org/name> "fanyang88/ARP_protocol"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/ODR_protocol_implementation> <https://schema.org/codeRepository> <https://github.com/fanyang88/ODR_protocol_implementation> .
<https://github.com/SOYJUN/threadpool-1> <https://schema.org/dateCreated> "2015-11-11T14:45:39"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/omsanket> <https://schema.org/author> <https://github.com/omsanket/CourseraTest> .
<https://github.com/sreeks1812/Script-Nonce-Module-for-Apache> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/omsanket> <https://schema.org/author> <https://github.com/omsanket/-Tour-Application-using-C-language> .
<https://github.com/da-x-ace> <https://schema.org/author> <https://github.com/da-x-ace/multicast-tour-application> .
<https://github.com/vamsi44/Extended-Integrity-Support-for--WRAPFS--File-System> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/da-x-ace/Authorship-Attribution> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q28865> .
<https://github.com/fanyang88/Tic_Tac_Toe> <https://schema.org/dateModified> "2015-10-05T22:33:39"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/vamsi44/On-Demand-Shortest-Hop-Routing> <https://schema.org/codeRepository> <https://github.com/vamsi44/On-Demand-Shortest-Hop-Routing> .
<https://github.com/omsanket/-Tour-Application-using-C-language> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/vamsi44/Content-Security-Policy-Script-Nonce-Filter-for-Apache> <https://schema.org/codeRepository> <https://github.com/vamsi44/Content-Security-Policy-Script-Nonce-Filter-for-Apache> .
<https://github.com/SOYJUN/chatRoom> <https://schema.org/dateModified> "2015-10-25T18:53:37"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/macosunity> <https://schema.org/identifier> "3349399"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/vamsi44> <https://schema.org/identifier> "5461228"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/da-x-ace/SuperComputing-HW3> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q2407> .
<https://github.com/omsanket/BettingApp> <https://schema.org/identifier> "60554281"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/omsanket/PreemptiveOS> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/omsanket/Implementation-of-ODR-protocol-using-C-language> <https://schema.org/dateModified> "2015-02-19T07:27:42"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/vamsi44/Content-Security-Policy-Script-Nonce-Filter-for-Apache> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/fanyang88> <https://schema.org/author> <https://github.com/fanyang88/3D_triangulation> .
<https://github.com/SOYJUN/FTP-implement-based-on-UDP> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/omsanket/PreemptiveOS> <https://schema.org/identifier> "48206058"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/omsanket/TCP-socket-server-client-C-programming> <https://schema.org/dateCreated> "2015-02-19T06:54:57"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/Distributed-algorithm-Majority-voting> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/Tic_Tac_Toe> <https://schema.org/codeRepository> <https://github.com/fanyang88/Tic_Tac_Toe> .
<https://github.com/sreeks1812/Address-space-operations-support-for--wrapfs--stackable-file-system> <https://schema.org/codeRepository> <https://github.com/sreeks1812/Address-space-operations-support-for--wrapfs--stackable-file-system> .
<https://github.com/fanyang88/algorithms> <https://schema.org/dateModified> "2018-12-04T19:29:25"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/vamsi44> <https://schema.org/author> <https://github.com/vamsi44/Content-Security-Policy-Script-Nonce-Filter-for-Apache> .
<https://github.com/vamsi44/Extended-Address-Space-Operations-Support-for--WRAPFS--File-System> <https://schema.org/codeRepository> <https://github.com/vamsi44/Extended-Address-Space-Operations-Support-for--WRAPFS--File-System> .
<https://github.com/SOYJUN/chatRoom> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/SOYJUN/threadPool-POXIS-thread> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/zwlforever> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/da-x-ace/xcrypt-system-call> <https://schema.org/name> "da-x-ace/xcrypt-system-call"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/JSON-java> <https://schema.org/codeRepository> <https://github.com/fanyang88/JSON-java> .
<https://github.com/da-x-ace/Misc> <https://schema.org/identifier> "7928844"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/da-x-ace/System-Call-Inherit> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN/Application-with-raw-IP-sockets> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/SOYJUN/chatRoom> <https://schema.org/name> "SOYJUN/chatRoom"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN/XMLParser> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/omsanket/PreemptiveOS> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/vamsi44/Extended-Address-Space-Operations-Support-for--WRAPFS--File-System> <https://schema.org/dateModified> "2013-09-24T04:50:20"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/vamsi44/File-Transfer-Protocol> <https://schema.org/dateModified> "2018-12-17T03:26:18"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/da-x-ace/Shared-and-Distributed-Memory-Randomized-Quick-Sort> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/sreeks1812/Script-Nonce-Module-for-Apache> <https://schema.org/name> "sreeks1812/Script-Nonce-Module-for-Apache"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/JSON-java> <https://schema.org/description> "A reference implementation of a JSON package in Java."^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/ODR_protocol_implementation> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/SOYJUN/FTP-implement-based-on-UDP> <https://schema.org/identifier> "33744517"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/da-x-ace/Android_Project_Yamba_Client> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/SuriyaaKudoIsc> <https://schema.org/image> <https://avatars2.githubusercontent.com/u/5073946?v=4> .
<https://github.com/fanyang88/face-tracking> <https://schema.org/identifier> "4104789"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/fanyang88/leetcode_java> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/sreeks1812/system-call-to-check-integrity-of-a-file> <https://schema.org/description> "Added a new system call as a module to the Linux kernel (Vanilla 3.2.y) that performs an integrity check of a file. The system call takes an input file and then depending on the mode on which it is called returns the existing  integrity of the file, computes an updated integrity of the file and also verifies the integrity on opening it."^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/vamsi44/System-Call-for-checking-the-integrity-of-files> <https://schema.org/name> "vamsi44/System-Call-for-checking-the-integrity-of-files"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/sreeks1812> <https://schema.org/author> <https://github.com/sreeks1812/system-call-to-check-integrity-of-a-file> .
<https://github.com/da-x-ace> <https://schema.org/author> <https://github.com/da-x-ace/openSSL-compatible-RSA-Engine> .
<https://github.com/SuriyaaKudoIsc> <https://schema.org/name> "Suriyaa Sundararuban"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <https://schema.org/description> "Overview  For this assignment you will be developing and implementing :  An On-Demand shortest-hop Routing (ODR) protocol for networks of fixed but arbitrary and unknown connectivity, using PF_PACKET sockets. The implementation is based on (a simplified version of) the AODV algorithm.  Time client and server applications that send requests and replies to each other across the network using ODR. An API you will implement using Unix domain datagram sockets enables applications to communicate with the ODR mechanism running locally at their nodes. I shall be discussing the assignment in class on Wednesday, October 29, and Monday, November 3.  The following should prove useful reference material for the assignment :  Sections 15.1, 15.2, 15.4 & 15.6, Chapter 15, on Unix domain datagram sockets.  PF_PACKET(7) from the Linux manual pages. You might find these notes made by a past CSE 533 student useful. Also, the following link http://www.pdbuchan.com/rawsock/rawsock.html contains useful code samples that use PF_PACKET sockets (as well as other code samples that use raw IP sockets which you do not need for this assignment, though you will be using these types of sockets for Assignment 4). Charles E. Perkins & Elizabeth M. Royer. \u201CAd-hoc On-Demand Distance Vector Routing.\u201D Proceedings of the 2nd IEEE Workshop on Mobile Computing Systems and Applications, New Orleans, Louisiana, February 1999,  pp. 90 - 100.  The  VMware  environment  minix.cs.stonybrook.edu is a Linux box running VMware. A cluster of ten Linux virtual machines, called vm1 through vm10, on which you can gain access as root and run your code have been created on minix. See VMware Environment Hosts for further details.  VMware instructions  takes you to a page that explains how to use the system. The ten virtual machines have been configured into a small virtual intranet of Ethernet LANs whose topology is (in principle) unknown to you.  There is a course account cse533 on node minix, with home directory /users/cse533. In there, you will find a subdirectory Stevens/unpv13e , exactly as you are used to having on the cs system. You should develop your source code and makefiles for handing in accordingly. You will be  handing in  your source code on the minix node.  Note that you do not need to link against the socket library (-lsocket) in Linux. The same is true for -lnsl and -lresolv. For example, take a look at how the LIBS variable is defined for Solaris, in /home/courses/cse533/Stevens/unpv13e_solaris2.10/Make.defines (on compserv1, say) :  LIBS = ../libunp.a -lresolv -lsocket -lnsl -lpthread  But if you take a look at Make.defines on minix (/users/cse533/Stevens/unpv13e/Make.defines) you will find only:  LIBS = ../libunp.a -lpthread  The nodes vm1 , . . . . . , vm10 are all multihomed :  each has two (or more) interfaces. The interface  \u2018eth0 \u2019  should be completely ignored and is not to be used for this assignment (because it shows all ten nodes as if belonging to the same single Ethernet 192.168.1.0/24, rather than to an intranet composed of several Ethernets).  Note that vm1 , . . . . . , vm10 are virtual machines, not real ones. One implication of this is that you will not be able to find out what their (virtual) IP addresses are by using nslookup and such. To find out these IP addresses, you need to look at the file /etc/hosts on minix. More to the point, invoking gethostbyname for a given vm will return to you only the (primary) IP address associated with the interface eth0 of that vm (which is the interface you will not be using). It will not return to you any other IP address for the node. Similarly, gethostbyaddr will return the vm node name only if you give it the (primary) IP address associated with the interface eth0 for the node. It will return nothing if you give it any other IP address for the node, even though the address is perfectly valid. Because of this, and because it will ease your task to be able to use gethostbyname and gethostbyaddr in a straightforward way, we shall adopt the (primary) IP addresses associated with interfaces eth0 as the \u2018canonical\u2019 IP addresses for the nodes (more on this below).  Time client and server  A time server runs on each of the ten vm machines. The client code should also be available on each vm so that it can be evoked at any of them.  Normally, time clients/servers exchange request/reply messages using the TCP/UDP socket API that, effectively, enables them to receive service (indirectly, via the transport layer) from the local IP mechanism running at their nodes. You are to implement an API using Unix domain sockets to access the local ODR service directly (somewhat similar, in effect, to the way that raw sockets permit an application to access IP directly). Use Unix domain SOCK_DGRAM, rather than SOCK_STREAM, sockets (see Figures 15.5 & 15.6, pp. 418 - 419).  API  You need to implement a msg_send function that will be called by clients/servers to send requests/replies. The parameters of the function consist of : int          giving the socket descriptor for write char*     giving the \u2018canonical\u2019 IP address for the destination node, in presentation format int          giving the destination \u2018port\u2019 number char*     giving message to be sent int flag  if set, force a route rediscovery to the destination node even if a non-\u2018stale\u2019 route already exists (see below) msg_send will format these parameters into a single char sequence which is written to the Unix domain socket that a client/server process creates. The sequence will be read by the local ODR from a Unix domain socket that the ODR process creates for itself.  Recall that the \u2018canonical\u2019 IP address for a vm node is the (primary) IP address associated with the eth0 interface for the node. It is what will be returned to you by a call to gethostbyname.  Similarly, we need a msg_recv function which will do a (blocking) read on the application domain socket and return with : int       giving socket descriptor for read char*  giving message received char*  giving \u2018canonical\u2019 IP address for the source node of message, in presentation format int*     giving source \u2018port\u2019 number This information is written as a single char sequence by the ODR process to the domain socket that it creates for itself. It is read by msg_recv from the domain socket the client/server process creates, decomposed into the three components above, and returned to the caller of msg_recv.  Also see the section below entitled ODR and the API. Client  When a client is evoked at a node, it creates a domain datagram socket. The client should bind its socket to a \u2018temporary\u2019 (i.e., not \u2018well-known\u2019) sun_path name obtained from a call to tmpnam() (cf. line 10, Figure 15.6, p. 419) so that multiple clients may run at the same node.  Note that tmpnam() is actually highly deprecated. You should use the mkstemp() function instead - look up the online man pages on minix (\u2018man mkstemp\u2019) for details.   As you run client code again and again during the development stage, the temporary files created by the calls to tmpnam / mkstemp start to proliferate since these files are not automatically removed when the client code terminates. You need to explicitly remove the file created by the client evocation by issuing a call to unlink() or to remove() in your client code just before the client code exits. See the online man pages on minix (\u2018man unlink\u2019, \u2018man remove\u2019) for details. The client then enters an infinite loop repeating the steps below. The client prompts the user to choose one of vm1 , . . . . . , vm10 as a server node.  Client msg_sends a 1 or 2 byte message to server and prints out on stdout the message      client at node  vm i1  sending request to server at  vm i2 (In general, throughout this assignment, \u201Ctrace\u201D messages such as the one above should give the vm names and not IP addresses of the nodes.)  Client then blocks in msg_recv awaiting response. This attempt to read from the domain socket should be backed up by a timeout in case no response ever comes. I leave it up to you whether you \u2018wrap\u2019 the call to msg_recv in a timeout, or you implement the timeout inside msg_recv itself. When the client receives a response it prints out on stdout the message      client at node  vm i1 : received from   vm i2  <timestamp> If, on the other hand, the client times out, it should print out the message      client at node  vm i1 : timeout on response from   vm i2 The client then retransmits the message out, setting the flag parameter in msg_send to force a route rediscovery, and prints out an appropriate message on stdout. This is done only once, when a timeout for a given message to the server occurs for the first time.  Client repeats steps 1. - 3. Server  The server creates a domain datagram socket. The server socket is assumed to have a (node-local) \u2018well-known\u2019 sun_path name which it binds to. This \u2018well-known\u2019 sun_path name is designated by a (network-wide) \u2018well-known\u2019 \u2018port\u2019 value. The time client uses this \u2018port\u2019 value to communicate with the server.  The server enters an infinite sequence of calls to msg_recv followed by msg_send, awaiting client requests and responding to them. When it responds to a client request, it prints out on stdout the message                server at node  vm i1  responding to request from  vm i2 ODR  The ODR process runs on each of the ten vm machines. It is evoked with a single command line argument which gives a \u201Cstaleness\u201D time parameter, in seconds.  It uses get_hw_addrs (available to you on minix in ~cse533/Asgn3_code) to obtain the index, and associated (unicast) IP and Ethernet addresses for each of the node\u2019s interfaces, except for the eth0 and lo (loopback) interfaces, which should be ignored. In the subdirectory ~cse533/Asgn3_code (/users/cse533/Asgn3_code) on minix I am providing you with two functions, get_hw_addrs and prhwaddrs. These are analogous to the get_ifi_info_plus and prifinfo_plus of Assignment 2. Like get_ifi_info_plus, get_hw_addrs uses ioctl. get_hw_addrs gets the (primary) IP address, alias IP addresses (if any), HW address, and interface name and index value for each of the node's interfaces (including the loopback interface lo). prhwaddrs prints that information out. You should modify and use these functions as needed.  Note that if an interface has no HW address associated with it (this is, typically, the case for the loopback interface lo for example), then ioctl returns get_hw_addrs a HW address which is the equivalent of 00:00:00:00:00:00 .  get_hw_addrs stores this in the appropriate field of its data structures as it would with any HW address returned by ioctl, but when prhwaddrs comes across such an address, it prints a blank line instead of its usual \u2018HWaddr = xx:xx:xx:xx:xx:xx\u2019. The ODR process creates one or more PF_PACKET sockets. You will need to try out PF_PACKET sockets for yourselves and familiarize yourselves with how they behave. If, when you read from the socket and provide a sockaddr_ll structure, the kernel returns to you the index of the interface on which the incoming frame was received, then one socket will be enough. Otherwise, somewhat in the manner of Assignment 2, you shall have to create a PF_PACKET socket for every interface of interest (which are all the interfaces of the node, excluding interfaces lo and eth0 ), and bind a socket to each interface. Furthermore, if the kernel also returns to you the source Ethernet address of the frame in the sockaddr_ll structure, then you can make do with SOCK_DGRAM type PF_PACKET sockets; otherwise you shall have to use SOCK_RAW type sockets (although I would prefer you to use SOCK_RAW type sockets anyway, even if it turns out you can make do with SOCK_DGRAM type).  The socket(s) should have a protocol value (no larger than 0xffff so that it fits in two bytes; this value is given as a network-byte-order parameter in the call(s) to function socket) that identifies your ODR protocol. The <linux/if_ether.h> include file (i.e., the file /usr/include/linux/if_ether.h) contains protocol values defined for the standard protocols typically found on an Ethernet LAN, as well as other values such as ETH_P_ALL. You should set protocol to a value of your choice which is not a <linux/if_ether.h> value, but which is, hopefully, unique to yourself. Remember that you will all be running your code using the same root account on the vm1 , . . . . . , vm10 nodes. So if two of you happen to choose the same protocol value and happen to be running on the same vm node at the same time, your applications will receive each other\u2019s frames. For that reason, try to choose a protocol value for the socket(s) that is likely to be unique to yourself (something based on your Stony Brook student ID number, for example). This value effectively becomes the protocol value for your implementation of ODR, as opposed to some other cse 533 student's implementation. Because your value of protocol is to be carried in the frame type field of the Ethernet frame header, the value chosen should be not less than 1536 (0x600) so that it is not misinterpreted as the length of an Ethernet 802.3 frame.  Note from the man pages for packet(7) that frames are passed to and from the socket without any processing in the frame content by the device driver on the other side of the socket, except for calculating and tagging on the 4-byte CRC trailer for outgoing frames, and stripping that trailer before delivering incoming frames to the socket. Nevertheless, if you write a frame that is less than 60 bytes, the necessary padding is automatically added by the device driver so that the frame that is actually transmitted out is the minimum Ethernet size of 64 bytes. When reading from the socket, however, any such padding that was introduced into a short frame at the sending node to bring it up to the minimum frame size is not stripped off - it is included in what you receive from the socket (thus, the minimum number of bytes you receive should never be less than 60). Also, you will have to build the frame header for outgoing frames yourselves (assuming you use SOCK_RAW type sockets). Bear in mind that the field values in that header have to be in network order. The ODR process also creates a domain datagram socket for communication with application processes at the node, and binds the socket to a \u2018well known\u2019 sun_path name for the ODR service.  Because it is dealing with fixed topologies, ODR is, by and large, considerably simpler than AODV. In particular, discovered routes are relatively stable and there is no need for all the paraphernalia that goes with the possibility of routes changing (such as maintenance of active nodes in the routing tables and timeout mechanisms; timeouts on reverse links; lifetime field in the RREP messages; etc.)  Nor will we be implementing source_sequence_#s (in the RREQ messages), and dest_sequence_# (in RREQ and RREP messages). In reality, we should (though we will not, for the sake of simplicity, be doing so) implement some sort of sequence number mechanism, or some alternative mechanism such as split-horizon for example, if we are to avoid possible scenarios of routing loops in a \u201Ccount to infinity\u201D context (I shall explain this point in class).  However, we want ODR to discover shortest-hop paths, and we want it to do so in a reasonably efficient manner. This necessitates having one or two aspects of its operations work in a different, possibly slightly more complicated, way than AODV does. ODR has several basic responsibilities :  Build and maintain a routing table. For each destination in the table, the routing table structure should include, at a minimum, the next-hop node (in the form of the Ethernet address for that node) and outgoing interface index, the number of hops to the destination, and a timestamp of when the the routing table entry was made or last \u201Creconfirmed\u201D / updated. Note that a destination node in the table is to be identified only by its \u2018canonical\u2019 IP address, and not by any other IP addresses the node has.  Generate a RREQ in response to a time client calling msg_send for a destination for which ODR has no route (or for which a route exists, but msg_send has the flag parameter set or the route has gone \u2018stale\u2019 \u2013 see below), and \u2018flood\u2019 the RREQ out on all the node\u2019s interfaces (except for the interface it came in on and, of course, the interfaces eth0 and lo). Flooding is done using an Ethernet broadcast destination address (0xff:ff:ff:ff:ff:ff) in the outgoing frame header.   Note that a copy of the broadcast packet is supposed to / might be looped back to the node that sends it (see p. 535 in the Stevens textbook). ODR will have to take care not to treat these copies as new incoming RREQs.   Also note that ODR at the client node increments the broadcast_id every time it issues a new RREQ for any destination node. When a RREQ is received, ODR has to generate a RREP if it is at the destination node, or if it is at an intermediate node that happens to have a route (which is not \u2018stale\u2019 \u2013 see below) to the destination. Otherwise, it must propagate the RREQ by flooding it out on all the node\u2019s interfaces (except the interface the RREQ arrived on). Note that as it processes received RREQs, ODR should enter the \u2018reverse\u2019 route back to the source node into its routing table, or update an existing entry back to the source node if the RREQ received shows a shorter-hop route, or a route with the same number of hops but going through a different neighbour. The timestamp associated with the table entry should be updated whenever an existing route is either \u201Creconfirmed\u201D or updated. Obviously, if the node is going to generate a RREP, updating an existing entry back to the source node with a more efficient route, or a same-hops route using a different neighbour, should be done before the RREP is generated.  Unlike AODV, when an intermediate node receives a RREQ for which it generates a RREP, it should nevertheless continue to flood the RREQ it received if the RREQ pertains to a source node whose existence it has heretofore been unaware of, or the RREQ gives it a more efficient route than it knew of back to the source node (the reason for continuing to flood the RREQ is so that other nodes in the intranet also become aware of the existence of the source node or of the potentially more optimal reverse route to it, and update their tables accordingly). However, since an RREP for this RREQ is being sent by our node, we do not want other nodes who receive the RREQ propagated by our node, and who might be in a position to do so, to also send RREPs. So we need to introduce a field in the RREQ message, not present in the AODV specifications, which acts like a \u201CRREP already sent\u201D field. Our node sets this field before further propagating the RREQ and nodes receiving an RREQ with this field set do not send RREPs in response, even if they are in a position to do so.  ODR may, of course, receive multiple, distinct instances of the same RREQ (the combination of source_addr and broadcast_id uniquely identifies the RREQ). Such RREQs should not be flooded out unless they have a lower hop count than instances of that RREQ that had previously been received.  By the same token, if ODR is in a position to send out a RREP, and has already done so for this, now repeating, RREQ ,  it should not send out another RREP unless the RREQ shows a more efficient, previously unknown, reverse route back to the source node. In other words, ODR should not generate essentially duplicative RREPs, nor generate RREPs to instances of RREQs that reflect reverse routes to the source that are not more efficient than what we already have. Relay RREPs received back to the source node (this is done using the \u2018reverse\u2019 route entered into the routing table when the corresponding RREQ was processed). At the same time, a \u2018forward\u2019 path to the destination is entered into the routing table. ODR could receive multiple, distinct RREPs for the same RREQ. The \u2018forward\u2019 route entered in the routing table should be updated to reflect the shortest-hop route to the destination, and RREPs reflecting suboptimal routes should not be relayed back to the source. In general, maintaining a route and its associated timestamp in the table in response to RREPs received is done in the same manner described above for RREQs.  Forward time client/server messages along the next hop. (The following is important \u2013 you will lose points if you do not implement it.) Note that such application payload messages (especially if they are the initial request from the client to the server, rather than the server response back to the client) can be like \u201Cfree\u201D RREPs, enabling nodes along the path from source (client) to destination (server) node to build a reverse path back to the client node whose existence they were heretofore unaware of (or, possibly, to update an existing route with a more optimal one). Before it forwards an application payload message along the next hop, ODR at an intermediate node (and also at the final destination node) should use the message to update its routing table in this way. Thus, calls to msg_send by time servers should never cause ODR at the server node to initiate RREQs, since the receipt of a time client request implies that a route back to the client node should now exist in the routing table. The only exception to this is if the server node has a staleness parameter of zero (see below). A routing table entry has associated with it a timestamp that gives the time the entry was made into the table. When a client at a node calls msg_send, and if an entry for the destination node already exists in the routing table, ODR first checks that the routing information is not \u2018stale\u2019. A stale routing table entry is one that is older than the value defined by the staleness parameter given as a command line argument to the ODR process when it is executed. ODR deletes stale entries (as well as non-stale entries when the flag parameter in msg_send is set) and initiates a route rediscovery by issuing a RREQ for the destination node. This will force periodic updating of the routing tables to take care of failed nodes along the current path, Ethernet addresses that might have changed, and so on. Similarly, as RREQs propagate through the intranet, existing stale table entries at intermediate nodes are deleted and new route discoveries propagated. As noted above when discussing the processing of RREQs and RREPs, the associated timestamp for an existing table entry is updated in response to having the route either \u201Creconfirmed\u201D or updated (this applies to both reverse routes, by virtue of RREQs received, and to forward routes, by virtue of RREPs). Finally, note that a staleness parameter of 0 essentially indicates that the discovered route will be used only once, when first discovered, and then discarded. Effectively, an ODR with staleness parameter 0 maintains no real routing table at all ;  instead, it forces route discoveries at every step of its operation. As a practical matter, ODR should be run with staleness parameter values that are considerably larger than the longest RTT on the intranet, otherwise performance will degrade considerably (and collapse entirely as the parameter values approach 0). Nevertheless, for robustness, we need to implement a mechanism by which an intermediate node that receives a RREP or application payload message for forwarding and finds that its relevant routing table entry has since gone stale, can intiate a RREQ to rediscover the route it needs.  RREQ, RREP, and time client/server request/response messages will all have to be carried as encapsulated ODR protocol messages that form the data payload of Ethernet frames. So we need to design the structure of ODR protocol messages. The format should contain a type field (0 for RREQ, 1 for RREP, 2 for application payload ). The remaining fields in an ODR message will depend on what type it is. The fields needed for (our simplified versions of AODV\u2019s) RREQ and RREP should be fairly clear to you, but keep in mind that you need to introduce two extra fields:  The \u201CRREP already sent\u201D bit or field in RREQ messages, as mentioned above.  A \u201Cforced discovery\u201D bit or field in both RREQ and RREP messages:  When a client application forces route rediscovery, this bit should be set in the RREQ issued by the client node ODR.  Intermediate nodes that are not the destination node but which do have a route to the destination node should not respond with RREPs to an RREQ which has the forced discovery field set. Instead, they should continue to flood the RREQ so that it eventually reaches the destination node which will then respond with an RREP.  The intermediate nodes relaying such an RREQ must update their \u2018reverse\u2019 route back to the source node accordingly, even if the new route is less efficient (i.e., has more hops) than the one they currently have in their routing table.  The destination node responds to the RREQ with an RREP in which this field is also set.  Intermediate nodes that receive such a forced discovery RREP must update their \u2018forward\u2019 route to the destination node accordingly, even if the new route is less efficient (i.e., has more hops) than the one they currently have in their routing table.  This behaviour will cause a forced discovery RREQ to be responded to only by the destination node itself and not any other node, and will cause intermediate nodes to update their routing tables to both source and destination nodes in accordance with the latest routing information received, to cover the possibility that older routes are no longer valid because nodes and/or links along their paths have gone down. A type 2, application payload, message needs to contain the following type of information :  type  =  2 \u2018canonical\u2019 IP address of source node \u2018port\u2019 number of source application process (This, of course, is not a real port number in the TCP/UDP sense, but simply a value that ODR at the source node uses to designate the sun_path name for the source application\u2019s domain socket.) \u2018canonical\u2019 IP address of destination node \u2018port\u2019 number of destination application process (This is passed to ODR by the application process at the source node when it calls msg_send. Its designates the sun_path name for an application\u2019s domain socket at the destination node.) hop count (This starts at 0 and is incremented by 1 at each hop so that ODR can make use of the message to update its routing table, as discussed above.) number of bytes in application message The fields above essentially constitute a \u2018header\u2019 for the ODR message. Note that fields which you choose to have carry numeric values (rather than ascii characters, for example) must be in network byte order. ODR-defined numeric-valued fields in type 0, RREQ, and type 1, RREP, messages must, of course, also be in network byte order.  Also note that only the \u2018canonical\u2019 IP addresses are used for the source and destination nodes in the ODR header. The same has to be true in the headers for type 0, RREQ, and type 1, RREP, messages. The general rule is that ODR messages only carry \u2018canonical\u2019 IP node addresses.  The last field in the type 2 ODR message is essentially the data payload of the message.  application message given in the call to msg_send An ODR protocol message is encapsulated as the data payload of an Ethernet frame whose header it fills in as follows :  source address  =  Ethernet address of outgoing interface of the current node where ODR is processing the message. destination address  =  Ethernet broadcast address for type 0 messages; Ethernet address of next hop node for type 1 & 2 messages. protocol field  =  protocol value for the ODR PF_PACKET socket(s). Last but not least, whenever ODR writes an Ethernet frame out through its socket, it prints out on stdout the message      ODR at node  vm i1 : sending      frame  hdr    src  vm i1      dest  addr                                                       ODR msg      type n     src  vm i2      dest  vm i3 where addr is in presentation format (i.e., hexadecimal xx:xx:xx:xx:xx:xx) and gives the destination Ethernet address in the outgoing frame header. Other nodes in the message should be identified by their vm name. A message should be printed out for each packet sent out on a distinct interface.  ODR and the API  When the ODR process first starts, it must construct a table in which it enters all well-known \u2018port\u2019 numbers and their corresponding sun_path names. These will constitute permanent entries in the table.  Thereafter, whenever it reads a message off its domain socket, it must obtain the sun_path name for the peer process socket and check whether that name is entered in the table. If not, it must select an \u2018ephemeral\u2019 \u2018port\u2019 value by which to designate the peer sun_path name and enter the pair  < port value , sun_path name >  into the table. Such entries cannot be permanent otherwise the table will grow unboundedly in time, with entries surviving for ever, beyond the peer processes\u2019 demise. We must associate a time_to_live field with a non-permanent table entry, and purge the entry if nothing is heard from the peer for that amount of time. Every time a peer process for which a non-permanent table entry exists communicates with ODR, its time_to_live value should be reinitialized.  Note that when ODR writes to a peer, it is possible for the write to fail because the peer does not exist :  it could be a \u2018well-known\u2019 service that is not running, or we could be in the interval between a process with a non-permanent table entry terminating and the expiration of its time_to_live value. Notes  A proper implementation of ODR would probably require that RREQ and RREP messages be backed up by some kind of timeout and retransmission mechanism since the network transmission environment is not reliable. This would considerably complicate the implementation (because at any given moment, a node could have multiple RREQs that it has flooded out, but for which it has still not received RREPs; the situation is further complicated by the fact that not all intermediate nodes receiving and relaying RREQs necessarily lie on a path to the destination, and therefore should expect to receive RREPs), and, learning-wise, would not add much to the experience you should have gained from Assignment 2."^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88> <https://schema.org/author> <https://github.com/fanyang88/distributed-algorithm-implementation-maekawa-s-algorithm> .
<https://github.com/da-x-ace/multicast-tour-application> <https://schema.org/description> "Designed an application which uses raw IP sockets to walk through (tour) an ordered list of nodes in a simulated VMware environment. Implemented ping, ARP and multicast mechanisms in user-space."^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/distributed-algorithm_Agarwal-El-Abbadi> <https://schema.org/codeRepository> <https://github.com/fanyang88/distributed-algorithm_Agarwal-El-Abbadi> .
<https://github.com/SOYJUN/SBU-OS-proj> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/sreeks1812/On-Demand-Distance-Vector-Routing-for-networks-of-arbitrary-and-unknown-connectivity> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/da-x-ace/xcrypt-system-call> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88> <https://schema.org/author> <https://github.com/fanyang88/JSON-java> .
<https://github.com/jorgemachucav> <https://schema.org/identifier> "47221983"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/SOYJUN/registerSys> <https://schema.org/description> "[COMPONENT] for register and log in step"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/da-x-ace/System-Call-Inherit> <https://schema.org/identifier> "7929000"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/omsanket> <https://schema.org/author> <https://github.com/omsanket/FTP-using-UDP-socket-server-client-C-programming> .
<https://github.com/SOYJUN/SBUshell> <https://schema.org/dateModified> "2015-04-10T19:54:01"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/da-x-ace> <https://schema.org/image> <https://avatars2.githubusercontent.com/u/3432910?v=4> .
<https://github.com/fanyang88/friendface> <https://schema.org/dateCreated> "2012-04-22T14:26:16"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/C-Thread-Pool> <https://schema.org/name> "SOYJUN/C-Thread-Pool"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/Tic_Tac_Toe> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q2005> .
<https://github.com/da-x-ace/Authorship-Attribution> <https://schema.org/identifier> "7928762"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/sreeks1812/Address-space-operations-support-for--wrapfs--stackable-file-system> <https://schema.org/identifier> "12839379"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/omsanket/PreemptiveOS> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/SOYJUN/XMLParser> <https://schema.org/identifier> "44393466"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/fanyang88/Distributed-algorithm-Majority-voting> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/da-x-ace/Misc> <https://schema.org/description> "Some random Algorithms Question"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/da-x-ace/multicast-tour-application> <https://schema.org/dateCreated> "2013-01-31T02:40:27"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/vamsi44/Content-Security-Policy-Script-Nonce-Filter-for-Apache> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/SOYJUN> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20204892> .
<https://github.com/fanyang88/particle-system> <https://schema.org/description> "an android project to simulate particle system"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88> <https://schema.org/author> <https://github.com/fanyang88/leetcode-in-js> .
<https://github.com/SOYJUN/C-Thread-Pool> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/fanyang88/leetcode-in-js> <https://schema.org/dateModified> "2018-08-23T22:17:36"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/Tic_Tac_Toe> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/omsanket/TCP-socket-server-client-C-programming> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/da-x-ace/SuperComputing-HW3> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/fanyang88> <https://schema.org/author> <https://github.com/fanyang88/scraper> .
<https://github.com/zwlforever> <https://schema.org/image> <https://avatars3.githubusercontent.com/u/8939305?v=4> .
<https://github.com/fanyang88/ODR_protocol_implementation> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/practise> <https://schema.org/dateCreated> "2016-10-20T18:37:18"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/chatRoom> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/sreeks1812/Adding-reliability-to-UDP> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/fanyang88/distributed-algorithm_Agarwal-El-Abbadi> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/fanyang88/JSON-java> <https://schema.org/dateCreated> "2012-12-29T21:02:56"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/C-Thread-Pool> <https://schema.org/dateCreated> "2015-11-13T20:36:06"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/algorithms> <https://schema.org/identifier> "145913326"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/da-x-ace/SuperComputing-HW3> <https://schema.org/identifier> "7927561"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/da-x-ace/System-Call-Inherit> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/fanyang88/friendface> <https://schema.org/codeRepository> <https://github.com/fanyang88/friendface> .
<https://github.com/omsanket/TCP-socket-server-client-C-programming> <https://schema.org/identifier> "31004633"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/fanyang88/Roman_Numeral_converter> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/da-x-ace/System-Call-Inherit> <https://schema.org/codeRepository> <https://github.com/da-x-ace/System-Call-Inherit> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <https://schema.org/name> "SOYJUN/Implement-ODR-protocol"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN/registerSys> <https://schema.org/dateCreated> "2015-10-27T18:57:35"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/vamsi44/File-Transfer-Protocol> <https://schema.org/description> "Implemented a primitive file transfer protocol for Unix platforms in user space to perform reliable file transfer over UDP. It Involves adding TCP-like features such as acknowledgements, slow start, congestion control, flow control, fast retransmit, and sliding window mechanism. Implemented an algorithm that simulates an unreliable network for testing purposes."^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN> <https://schema.org/author> <https://github.com/SOYJUN/aws-sdk-ruby> .
<https://github.com/fanyang88/reliable_UDP> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/jorgemachucav> <https://schema.org/BookmarkAction> <https://github.com/SOYJUN/Implement-ODR-protocol> .
<https://github.com/SOYJUN/FTP-implement-based-on-UDP> <https://schema.org/dateCreated> "2015-04-10T18:37:13"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/threadPool-POXIS-thread> <https://schema.org/codeRepository> <https://github.com/SOYJUN/threadPool-POXIS-thread> .
<https://github.com/fanyang88/reliable_UDP> <https://schema.org/dateModified> "2013-12-23T12:31:36"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/Application-with-raw-IP-sockets> <https://schema.org/dateCreated> "2015-04-10T18:55:47"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/da-x-ace/Address-Space-ops-in-Wrapfs> <https://schema.org/dateModified> "2013-12-11T11:48:16"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/phpone> <https://schema.org/name> "fanyang88/phpone"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/omsanket/CourseraTest> <https://schema.org/dateCreated> "2016-05-25T01:26:37"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/algorithms> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/vamsi44/Extended-Address-Space-Operations-Support-for--WRAPFS--File-System> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q14663> .
<https://github.com/SOYJUN/Application-with-raw-IP-sockets> <https://schema.org/dateModified> "2019-03-21T00:10:18"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/C-Thread-Pool> <https://schema.org/codeRepository> <https://github.com/SOYJUN/C-Thread-Pool> .
<https://github.com/da-x-ace/On-Demand-Routing> <https://schema.org/dateModified> "2013-12-31T11:19:12"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/FTP-implement-based-on-UDP> <https://schema.org/description> "The aim of this assignment is to have you do UDP socket client / server programming with a focus on two broad aspects :  Setting up the exchange between the client and server in a secure way despite the lack of a formal connection (as in TCP) between the two, so that \u2018outsider\u2019 UDP datagrams (broadcast, multicast, unicast - fortuitously or maliciously) cannot intrude on the communication.  Introducing application-layer protocol data-transmission reliability, flow control and congestion control in the client and server using TCP-like ARQ sliding window mechanisms. The second item above is much more of a challenge to implement than the first, though neither is particularly trivial. But they are not tightly interdependent; each can be worked on separately at first and then integrated together at a later stage.  Apart from the material in Chapters 8, 14 & 22 (especially Sections 22.5 - 22.7), and the experience you gained from the preceding assignment, you will also need to refer to the following :  ioctl function (Chapter 17).  get_ifi_info function (Section 17.6, Chapter 17). This function will be used by the server code to discover its node\u2019s network interfaces so that it can bind all its interface IP addresses (see Section 22.6).  \u2018Race\u2019 conditions (Section 20.5, Chapter 20) You also need a thorough understanding of how the TCP protocol implements reliable data transfer, flow control and congestion control. Chapters 17- 24 of   TCP/IP Illustrated, Volume 1  by W. Richard Stevens gives a good overview of TCP. Though somewhat dated for some things (it was published in 1994), it remains, overall, a good basic reference.  Overview  This assignment asks you to implement a primitive file transfer protocol for Unix platforms, based on UDP, and with TCP-like reliability added to the transfer operation using timeouts and sliding-window mechanisms, and implementing flow and congestion control. The server is a concurrent server which can handle multiple clients simultaneously. A client gives the server the name of a file. The server forks off a child which reads directly from the file and transfers the contents over to the client using UDP datagrams. The client prints out the file contents as they come in, in order, with nothing missing and with no duplication of content, directly on to stdout (via the receiver sliding window, of course, but with no other intermediate buffering). The file to be transferred can be of arbitrary length, but its contents are always straightforward ascii text.  As an aside let me mention that assuming the file contents ascii is not as restrictive as it sounds. We can always pretend, for example, that binary files are base64 encoded (\u201CASCII armor\u201D). A real file transfer protocol would, of course, have to worry about transferring files between heterogeneous platforms with different file structure conventions and semantics. The sender would first have to transform the file into a platform-independent, protocol-defined, format (using, say, ASN.1, or some such standard), and the receiver would have to transform the received file into its platform\u2019s native file format. This kind of thing can be fairly time consuming, and is certainly very tedious, to implement, with little educational value - it is not part of this assignment.  Arguments for the server  You should provide the server with an input file server.in from which it reads the following information, in the order shown, one item per line :  Well-known port number for server. Maximum sending sliding-window size (in datagram units). You will not be handing in your server.in file. We shall create our own when we come to test your code. So it is important that you stick strictly to the file name and content conventions specified above. The same applies to the client.in input file below.  Arguments for the client  The client is to be provided with an input file client.in from which it reads the following information, in the order shown, one item per line :  IP address of server (not the hostname). Well-known port number of server. filename to be transferred. Receiving sliding-window size (in datagram units). Random generator seed value. Probability p of datagram loss. This should be a real number in the range [ 0.0 , 1.0 ]  (value 0.0 means no loss occurs; value 1.0 means all datagrams all lost). The mean \u00B5, in milliseconds, for an exponential distribution controlling the rate at which the client reads received datagram payloads from its receive buffer. Operation  Server starts up and reads its arguments from file server.in.  As we shall see, when a client communicates with the server, the server will want to know what IP address that client is using to identify the server (i.e. , the destination IP address in the incoming datagram). Normally, this can be done relatively straightforwardly using the IP_RECVDESTADDR socket option, and picking up the information using the ancillary data (\u2018control information\u2019) capability of the recvmsg function. Unfortunately, Solaris 2.10 does not support the IP_RECVDESTADDR option (nor, incidentally, does it support the msg_flags option in msghdr - see p.390). This considerably complicates things.  In the absence of IP_RECVDESTADDR, what the server has to do as part of its initialization phase is to bind each IP address it has (and, simultaneously, its well-known port number, which it has read in from server.in) to a separate UDP socket. The code in Section 22.6, which uses the get_ifi_info function, shows you how to do that. However, there are important differences between that code and the version you want to implement. The code of Section 22.6 binds the IP addresses and forks off a child for each address that is bound to. We do not want to do that. Instead you should have an array of socket descriptors. For each IP address, create a new socket and bind the address (and well-known port number) to the socket without forking off child processes. Creating child processes comes later, when clients arrive.  The code of Section 22.6 also attempts to bind broadcast addresses. We do not want to do this. It binds a wildcard IP address, which we certainly do not want to do either. We should bind strictly only unicast addresses (including the loopback address).  The get_ifi_info function (which the code in Section 22.6 uses) has to be modified so that it also gets the network masks for the IP addresses of the node, and adds these to the information stored in the linked list of ifi_info structures (see Figure 17.5, p.471) it produces. As you go binding each IP address to a distinct socket, it will be useful for later processing to build your own array of structures, where a structure element records the following information for each socket :  sockfd IP address bound to the socket network mask for the IP address subnet address (obtained by doing a bit-wise and between the IP address and its network mask)  Report, in a ReadMe file which you hand in with your code, on the modifications you had to introduce to ensure that only unicast addresses are bound, and on your implementation of the array of structures described above.  You should print out on stdout, with an appropriate message and appropriately formatted in dotted decimal notation, the IP address, network mask, and subnet address for each socket in your array of structures (you do not need to print the sockfd).  The server now uses select to monitor the sockets it has created for incoming datagrams. When it returns from select, it must use recvfrom or recvmsg to read the incoming datagram (see 6. below).  When a client starts, it first reads its arguments from the file client.in.  The client checks if the server host is \u2018local\u2019 to its (extended) Ethernet. If so, all its communication to the server is to occur as MSG_DONTROUTE (or SO_DONTROUTE socket option). It determines if the server host is \u2018local\u2019 as follows. The first thing the client should do is to use the modified get_ifi_info function to obtain all of its IP addresses and associated network masks.  Print out on stdout, in dotted decimal notation and with an appropriate message, the IP addresses and network masks obtained.  In the following, IPserver designates the IP address the client will use to identify the server, and IPclient designates the IP address the client will choose to identify itself.  The client checks whether the server is on the same host. If so, it should use the loopback address 127.0.0.1 for the server (i.e. , IPserver = 127.0.0.1). IPclient should also be set to the loopback address.  Otherwise it proceeds as follows:  IPserver is set to the IP address for the server in the client.in file. Given IPserver and the (unicast) IP addresses and network masks for the client returned by get_ifi_info in the linked list of ifi_info structures, you should be able to figure out if the server node is \u2018local\u2019 or not. This will be discussed in class; but let me just remind you here that you should use \u2018longest prefix matching\u2019 where applicable.  If there are multiple client addresses, and the server host is \u2018local\u2019, the client chooses an IP address for itself, IPclient, which matches up as \u2018local\u2019 according to your examination above. If the server host is not \u2018local\u2019, then IPclient can be chosen arbitrarily.  Print out on stdout the results of your examination, as to whether the server host is \u2018local\u2019 or not, as well as the IPclient and IPserver addresses selected.  Note that this manner of determining whether the server is local or not is somewhat clumsy and \u2018over-engineered\u2019, and, as such, should be viewed more in the nature of a pedagogical exercise. Ideally, we would like to look up the server IP address(es) in the routing table (see Section 18.3). This requires that a routing socket be created, for which we need superuser privilege. Alternatively, we might want to dump out the routing table, using the sysctl function for example (see Section 18.4), and examine it directly. Unfortunately, Solaris 2.10 does not support sysctl.   Furthermore, note that there is a slight problem with the address 130.245.1.123/24 assigned to compserv3 (see rightmost column of file hosts, and note that this particular compserv3 address \u201Coverlaps\u201D with the 130.245.1.x/28 addresses in that same column assigned to compserv1, compserv2 & comserv4). In particular, if the client is running on compserv3 and the server on any of the other three compservs, and if that server node is also being identified to the client by its /28 (rather than its /24) address, then the client will get a \u201Cfalse positive\u201D when it tests as to whether the server node is local or not. In other words, the client will deem the server node to be local, whereas in fact it should not be considered local. Because of this, it is perhaps best simply not to use compserv3 to run the client (but it is o.k. to use it to run the server).   Finally, using MSG_DONTROUTE where possible would seem to gain us efficiency, in as much as the kernel does not need to consult the routing table for every datagram sent. But, in fact, that is not so. Recall that one effect of connect with UDP sockets is that routing information is obtained by the kernel at the time the connect is issued. That information is cached and used for subsequent sends from the connected socket (see p.255).  The client now creates a UDP socket and calls bind on IPclient, with 0 as the port number. This will cause the kernel to bind an ephemeral port to the socket.  After the bind, use the getsockname function (Section 4.10) to obtain IPclient and the ephemeral port number that has been assigned to the socket, and print that information out on stdout, with an appropriate message and appropriately formatted.  The client connects its socket to IPserver and the well-known port number of the server.  After the connect, use the getpeername function (Section 4.10) to obtain IPserver and the well-known port number of the server, and print that information out on stdout, with an appropriate message and appropriately formatted.  The client sends a datagram to the server giving the filename for the transfer. This send needs to be backed up by a timeout in case the datagram is lost.  Note that the incoming datagram from the client will be delivered to the server at the socket to which the destination IP address that the datagram is carrying has been bound. Thus, the server can obtain that address (it is, of course, IPserver) and thereby achieve what IP_RECVDESTADDR would have given us had it been available.  Furthermore, the server process can obtain the IP address (this will, of course, be IPclient) and ephemeral port number of the client through the recvfrom or recvmsg functions.  The server forks off a child process to handle the client. The server parent process goes back to the select to listen for new clients. Hereafter, and unless otherwise stated, whenever we refer to the \u2018server\u2019, we mean the server child process handling the client\u2019s file transfer, not the server parent process.  Typically, the first thing the server child would be expected to do is to close all sockets it \u2018inherits\u2019 from its parent. However, this is not the case with us. The server child does indeed close the sockets it inherited, but not the socket on which the client request arrived. It leaves that socket open for now. Call this socket the \u2018listening\u2019 socket.  The server (child) then checks if the client host is local to its (extended) Ethernet. If so, all its communication to the client is to occur as MSG_DONTROUTE (or SO_DONTROUTE socket option).  If IPserver (obtained in 5. above) is the loopback address, then we are done. Otherwise, the server has to proceed with the following step.  Use the array of structures you built in 1. above, together with the addresses IPserver and IPclient to determine if the client is \u2018local\u2019.  Print out on stdout the results of your examination, as to whether the client host is \u2018local\u2019 or not. The server (child) creates a UDP socket to handle file transfer to the client. Call this socket the \u2018connection\u2019 socket. It binds the socket to IPserver, with port number 0 so that its kernel assigns an ephemeral port.  After the bind, use the getsockname function (Section 4.10) to obtain IPserver and the ephemeral port number that has been assigned to the socket, and print that information out on stdout, with an appropriate message and appropriately formatted.  The server then connects this \u2018connection\u2019 socket to the client\u2019s IPclient and ephemeral port number.  The server now sends the client a datagram, in which it passes it the ephemeral port number of its \u2018connection\u2019 socket as the data payload of the datagram. This datagram is sent using the \u2018listening\u2019 socket inherited from its parent, otherwise the client (whose socket is connected to the server\u2019s \u2018listening\u2019 socket at the latter\u2019s well-known port number) will reject it. This datagram must be backed up by the ARQ mechanism, and retransmitted in the event of loss.  Note that if this datagram is indeed lost, the client might well time out and retransmit its original request message (the one carrying the file name). In this event, you must somehow ensure that the parent server does not mistake this retransmitted request for a new client coming in, and spawn off yet another child to handle it. How do you do that? It is potentially more involved than it might seem. I will be discussing this in class, as well as \u2018race\u2019 conditions that could potentially arise, depending on how you code the mechanisms I present.  When the client receives the datagram carrying the ephemeral port number of the server\u2019s \u2018connection\u2019 socket, it reconnects its socket to the server\u2019s \u2018connection\u2019 socket, using IPserver and the ephemeral port number received in the datagram (see p.254). It now uses this reconnected socket to send the server an acknowledgment. Note that this implies that, in the event of the server timing out, it should retransmit two copies of its \u2018ephemeral port number\u2019 message, one on its \u2018listening\u2019 socket and the other on its \u2018connection\u2019 socket (why?).  When the server receives the acknowledgment, it closes the \u2018listening\u2019 socket it inherited from its parent. The server can now commence the file transfer through its \u2018connection\u2019 socket.  The net effect of all these binds and connects at server and client is that no \u2018outsider\u2019 UDP datagram (broadcast, multicast, unicast - fortuitously or maliciously) can now intrude on the communication between server and client.  Starting with the first datagram sent out, the client behaves as follows.  Whenever a datagram arrives, or an ACK is about to be sent out (or, indeed, the initial datagram to the server giving the filename for the transfer), the client uses some random number generator function random() (initialized by the client.in argument value seed) to decide with probability p (another client.in argument value) if the datagram or ACK should be discarded by way of simulating transmission loss across the network. (I will briefly discuss in class how you do this.) Adding reliability to UDP  The mechanisms you are to implement are based on TCP Reno. These include :  Reliable data transmission using ARQ sliding-windows, with Fast Retransmit. Flow control via receiver window advertisements. Congestion control that implements : SlowStart Congestion Avoidance (\u2018Additive-Increase/Multiplicative Decrease\u2019 \u2013 AIMD) Fast Recovery (but without the window-inflation aspect of Fast Recovery) Only some, and by no means all, of the details for these are covered below. The rest will be presented in class, especially those concerning flow control and TCP Reno\u2019s congestion control mechanisms in general :  Slow Start, Congestion Avoidance, Fast Retransmit and Fast Recovery.  Implement a timeout mechanism on the sender (server) side. This is available to you from Stevens, Section 22.5 . Note, however, that you will need to modify the basic driving mechanism of Figure 22.7 appropriately since the situation at the sender side is not a repetitive cycle of send-receive, but rather a straightforward progression of send-send-send-send- . . . . . . . . . . .  Also, modify the RTT and RTO mechanisms of Section 22.5 as specified below. I will be discussing the details of these modifications and the reasons for them in class.  Modify function rtt_stop (Fig. 22.13) so that it uses integer arithmetic rather than floating point. This will entail your also having to modify some of the variable and function parameter declarations throughout Section 22.5 from float to int, as appropriate.  In the unprrt.h header file (Fig. 22.10) set :           RTT_RXTMIN   to 1000 msec.   (1 sec. instead of the current value   3 sec.)           RTT_RXTMAX  to 3000 msec.   (3 sec. instead of the current value 60 sec.)           RTT_MAXNREXMT  to 12        (instead of the current value 3)  In function rtt_timeout (Fig. 22.14), after doubling the RTO in line 86, pass its value through the function rtt_minmax of Fig. 22.11 (somewhat along the lines of what is done in line 77 of rtt_stop, Fig. 22.13).  Finally, note that with the modification to integer calculation of the smoothed RTT and its variation, and given the small RTT values you will experience on the cs / sbpub network, these calculations should probably now be done on a millisecond or even microsecond scale (rather than in seconds, as is the case with Stevens\u2019 code). Otherwise, small measured RTTs could show up as 0 on a scale of seconds, yielding a negative result when we subtract the smoothed RTT from the measured RTT (line 72 of rtt_stop, Fig. 22.13).  Report the details of your modifications to the code of Section 22.5 in the ReadMe file which you hand in with your code.  We need to have a sender sliding window mechanism for the retransmission of lost datagrams; and a receiver sliding window in order to ensure correct sequencing of received file contents, and some measure of flow control. You should implement something based on TCP Reno\u2019s mechanisms, with cumulative acknowledgments, receiver window advertisements, and a congestion control mechanism I will explain in detail in class.  For a reference on TCP\u2019s mechanisms generally, see W. Richard Stevens,   TCP/IP Illustrated, Volume 1 , especially Sections 20.2 - 20.4  of  Chapter 20 ,  and Sections 21.1 - 21.8  of  Chapter 21 .  Bear in mind that our sequence numbers should count datagrams, not bytes as in TCP. Remember that the sender and receiver window sizes have to be set according to the argument values in client.in and server.in, respectively. Whenever the sender window becomes full and so \u2018locks\u2019, the server should print out a message to that effect on stdout. Similarly, whenever the receiver window \u2018locks\u2019, the client should print out a message on stdout.  Be aware of the potential for deadlock when the receiver window \u2018locks\u2019. This situation is handled by having the receiver process send a duplicate ACK which acts as a window update when its window opens again (see  Figure 20.3  and the discussion about it in TCP/IP Illustrated). However, this is not enough, because ACKs are not backed up by a timeout mechanism in the event they are lost. So we will also need to implement a persist timer driving window probes in the sender process (see  Sections 22.1 & 22.2  in Chapter 22 of TCP/IP Illustrated). Note that you do not have to worry about the Silly Window Syndrome discussed in Section 22.3 of TCP/IP Illustrated since the receiver process consumes \u2018full sized\u2019 512-byte messages from the receiver buffer (see 3. below).  Report on the details of the ARQ mechanism you implemented in the ReadMe file you hand in. Indeed, you should report on all the TCP mechanisms you implemented in the ReadMe file, both the ones discussed here, and the ones I will be discussing in class.  Make your datagram payload a fixed 512 bytes, inclusive of the file transfer protocol header (which must, at the very least, carry: the sequence number of the datagram; ACKs; and advertised window notifications).  The client reads the file contents in its receive buffer and prints them out on stdout using a separate thread. This thread sits in a repetitive loop till all the file contents have been printed out, doing the following.  It samples from an exponential distribution with mean \u00B5 milliseconds (read from the client.in file), sleeps for that number of milliseconds; wakes up to read and print all in-order file contents available in the receive buffer at that point; samples again from the exponential distribution; sleeps; and so on.  The formula     -1 \u00D7 \u00B5 \u00D7 ln( random( ) ) ,    where ln is the natural logarithm, yields variates from an exponential distribution with mean \u00B5, based on the uniformly-distributed variates over  ( 0 , 1 )  returned by random().  Note that you will need to implement some sort of mutual exclusion/semaphore mechanism on the client side so that the thread that sleeps and wakes up to consume from the receive buffer is not updating the state variables of the buffer at the same time as the main thread reading from the socket and depositing into the buffer is doing the same. Furthermore, we need to ensure that the main thread does not effectively monopolize the semaphore (and thus lock out for prolonged periods of time) the sleeping thread when the latter wakes up. See the textbook, Section 26.7, \u2018Mutexes: Mutual Exclusion\u2019,  pp.697-701. You might also find Section 26.8, \u2018Condition Variables\u2019,  pp.701-705, useful.  You will need to devise some way by which the sender can notify the receiver when it has sent the last datagram of the file transfer, without the receiver mistaking that EOF marker as part of the file contents. (Also, note that the last data segment could be a \u201Cshort\u201D segment of less than 512 bytes \u2013 your client needs to be able to handle this correctly somehow.) When the sender receives an ACK for the last datagram of the transfer, the (child) server terminates. The parent server has to take care of cleaning up zombie children.  Note that if we want a clean closing, the client process cannot simply terminate when the receiver ACKs the last datagram. This ACK could be lost, which would leave the (child) server process \u2018hanging\u2019, timing out, and retransmitting the last datagram. TCP attempts to deal with this problem by means of the TIME_WAIT state. You should have your receiver process behave similarly, sticking around in something akin to a TIME_WAIT state in case in case it needs to retransmit the ACK.  In the ReadMe file you hand in, report on how you dealt with the issues raised here: sender notifying receiver of the last datagram, clean closing, and so on. Output  Some of the output required from your program has been described in the section Operation above. I expect you to provide further output \u2013 clear, well-structured, well-laid-out, concise but sufficient and helpful \u2013 in the client and server windows by means of which we can trace the correct evolution of your TCP\u2019s behaviour in all its intricacies :  information (e.g., sequence number) on datagrams and acks sent and dropped, window advertisements, datagram retransmissions (and why :  dup acks or RTO); entering/exiting Slow Start and Congestion Avoidance, ssthresh and cwnd values; sender and receiver windows locking/unlocking; etc., etc. . . .  .  The onus is on you to convince us that the TCP mechanisms you implemented are working correctly. Too many students do not put sufficient thought, creative imagination, time or effort into this. It is not the TA\u2019s nor my responsibility to sit staring at an essentially blank screen, trying to summon up our paranormal psychology skills to figure out if your TCP implementation is really working correctly in all its very intricate aspects, simply because the transferred file seems to be printing o.k. in the client window. Nor is it our responsibility to strain our eyes and our patience wading through a mountain of obscure, ill-structured, hyper-messy, debugging-style output because, for example, your effort-conserving concept of what is \u2018suitable\u2019 is to dump your debugging output on us, relevant, irrelevant, and everything in between."^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/ODR_protocol_implementation> <https://schema.org/dateModified> "2013-11-03T22:18:45"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/distributed-algorithm_Agarwal-El-Abbadi> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/omsanket> <https://schema.org/author> <https://github.com/omsanket/TCP-socket-server-client-C-programming> .
<https://github.com/fanyang88> <https://schema.org/author> <https://github.com/fanyang88/distributed-algorithm_Agarwal-El-Abbadi> .
<https://github.com/SOYJUN/Implement-ODR-protocol> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/fanyang88/practise> <https://schema.org/codeRepository> <https://github.com/fanyang88/practise> .
<https://github.com/sreeks1812> <https://schema.org/author> <https://github.com/sreeks1812/Extended-attributes-support-for--wrapfs--stackable-file-system> .
<https://github.com/vamsi44> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Q20374321> .
<https://github.com/omsanket/BettingApp> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/fanyang88/phpone> <https://schema.org/identifier> "6539171"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/fanyang88/JSON-java> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/SOYJUN/threadpool-1> <https://schema.org/description> "A simple C++ threadpool based on POSIX threads."^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/sreeks1812> <https://schema.org/name> "sreekar reddy"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/omsanket/FTP-using-UDP-socket-server-client-C-programming> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/omsanket/BettingApp> <https://schema.org/dateModified> "2016-06-06T19:17:29"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88> <https://schema.org/author> <https://github.com/fanyang88/particle-system> .
<https://github.com/fanyang88/Distributed-algorithm-Majority-voting> <https://schema.org/identifier> "7361646"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/SOYJUN/threadpool-1> <https://schema.org/dateModified> "2015-11-11T14:47:28"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/XMLParser> <https://schema.org/dateModified> "2015-10-21T21:43:38"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/da-x-ace/xcrypt-system-call> <https://schema.org/dateModified> "2014-04-19T12:30:34"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/omsanket/Implementation-of-ODR-protocol-using-C-language> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/SOYJUN/FTP-implement-based-on-UDP> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/da-x-ace/System-Call-Inherit> <https://schema.org/dateModified> "2014-04-22T20:23:05"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/omsanket/SB_SHELL> <https://schema.org/dateModified> "2015-02-26T23:59:33"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/vamsi44/Extended-Integrity-Support-for--WRAPFS--File-System> <https://schema.org/dateModified> "2019-02-26T09:33:23"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/particle-system> <https://schema.org/name> "fanyang88/particle-system"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN/C-Thread-Pool> <https://schema.org/description> "A minimal but powerful thread pool in ANSI C"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/3D_triangulation> <https://schema.org/codeRepository> <https://github.com/fanyang88/3D_triangulation> .
<https://github.com/da-x-ace/On-Demand-Routing> <https://schema.org/identifier> "7928865"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/da-x-ace> <https://schema.org/author> <https://github.com/da-x-ace/Shared-and-Distributed-Memory-Randomized-Quick-Sort> .
<https://github.com/SOYJUN/TCP-socket-client-server> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/SOYJUN/threadpool-1> <https://schema.org/identifier> "45987575"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/fanyang88/JSON-java> <https://schema.org/identifier> "7370426"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/fanyang88/face-tracking> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q2407> .
<https://github.com/sreeks1812/Address-space-operations-support-for--wrapfs--stackable-file-system> <https://schema.org/dateModified> "2019-02-27T07:41:01"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/zwlforever> <https://schema.org/BookmarkAction> <https://github.com/SOYJUN/Implement-ODR-protocol> .
<https://github.com/vamsi44/On-Demand-Shortest-Hop-Routing> <https://schema.org/dateCreated> "2013-09-15T02:01:01"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/da-x-ace/Shared-and-Distributed-Memory-Randomized-Quick-Sort> <https://schema.org/identifier> "7928886"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/fanyang88/face-tracking> <https://schema.org/description> "an 3D game embedded face tracking"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN/registerSys> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/fanyang88/leetcode_java> <https://schema.org/identifier> "163878007"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/omsanket/Implementation-of-ODR-protocol-using-C-language> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/SOYJUN/registerSys> <https://schema.org/dateModified> "2015-10-27T19:38:41"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/da-x-ace/Misc> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q2407> .
<https://github.com/da-x-ace/xcrypt-system-call> <https://schema.org/identifier> "7929047"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/sreeks1812/system-call-to-check-integrity-of-a-file> <https://schema.org/dateModified> "2014-06-03T00:01:00"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/SOYJUN/Application-with-raw-IP-sockets> <https://schema.org/identifier> "33745337"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/fanyang88> <https://schema.org/author> <https://github.com/fanyang88/Distributed-algorithm-Majority-voting> .
<https://github.com/da-x-ace/Authorship-Attribution> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/fanyang88> <https://schema.org/contributor> <https://github.com/fanyang88/ODR_protocol_implementation> .
<https://github.com/SOYJUN/threadPool-POXIS-thread> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/omsanket> <https://schema.org/author> <https://github.com/omsanket/SB_SHELL> .
<https://github.com/SOYJUN> <https://www.wikidata.org/wiki/Property:P3919> <https://github.com/SOYJUN/Implement-ODR-protocol> .
<https://github.com/vamsi44/Extended-Address-Space-Operations-Support-for--WRAPFS--File-System> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/omsanket> <https://schema.org/author> <https://github.com/omsanket/PreemptiveOS> .
<https://github.com/da-x-ace/multicast-tour-application> <https://schema.org/codeRepository> <https://github.com/da-x-ace/multicast-tour-application> .
<https://github.com/da-x-ace/On-Demand-Routing> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/fanyang88/3D_triangulation> <https://schema.org/dateCreated> "2012-12-29T02:33:47"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/Tic_Tac_Toe> <https://schema.org/name> "fanyang88/Tic_Tac_Toe"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/vamsi44/Extended-Address-Space-Operations-Support-for--WRAPFS--File-System> <https://schema.org/name> "vamsi44/Extended-Address-Space-Operations-Support-for--WRAPFS--File-System"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/Roman_Numeral_converter> <https://schema.org/identifier> "7362178"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/fanyang88/3D_triangulation> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/arpitsardhana/ODR-on-local-LAN> <https://schema.org/dateModified> "2016-01-06T20:39:09"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/fanyang88/friendface> <https://schema.org/identifier> "4104466"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/da-x-ace/Address-Space-ops-in-Wrapfs> <https://schema.org/description> "Modified wrapfs open-source stackable file system (http://wrapfs.filesystem.org/) to implement address space operations. Added mount-time option to choose between address space operation and single page fault operation. Implemented encryption file system at the lower layer to demonstrate support for different data pages in upper and lower level file systems."^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN/FTP-implement-based-on-UDP> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/SOYJUN> <https://schema.org/author> <https://github.com/SOYJUN/registerSys> .
<https://github.com/da-x-ace/Authorship-Attribution> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/arpitsardhana/ODR-on-local-LAN> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/fanyang88> <https://schema.org/author> <https://github.com/fanyang88/face-tracking> .
<https://github.com/fanyang88/3D_triangulation> <https://schema.org/name> "fanyang88/3D_triangulation"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/ODR_protocol_implementation> <https://schema.org/dateCreated> "2012-12-29T00:26:25"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/omsanket/Implementation-of-ODR-protocol-using-C-language> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/face-tracking> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/fanyang88/distributed-algorithm_Agarwal-El-Abbadi> <https://schema.org/description> "None"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/omsanket> <https://www.wikidata.org/wiki/Property:P3919> <https://github.com/omsanket/Implementation-of-ODR-protocol-using-C-language> .
<https://github.com/da-x-ace/xcrypt-system-call> <https://schema.org/codeRepository> <https://github.com/da-x-ace/xcrypt-system-call> .
<https://github.com/SOYJUN/SBUshell> <https://schema.org/codeRepository> <https://github.com/SOYJUN/SBUshell> .
<https://github.com/fanyang88> <https://schema.org/author> <https://github.com/fanyang88/ARP_protocol> .
<https://github.com/fanyang88/algorithms> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q2005> .
<https://github.com/SOYJUN> <https://schema.org/author> <https://github.com/SOYJUN/threadpool-1> .
<https://github.com/fanyang88/Tic_Tac_Toe> <https://schema.org/identifier> "43716939"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/da-x-ace/Shared-and-Distributed-Memory-Randomized-Quick-Sort> <https://schema.org/name> "da-x-ace/Shared-and-Distributed-Memory-Randomized-Quick-Sort"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/practise> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/da-x-ace/Authorship-Attribution> <https://schema.org/codeRepository> <https://github.com/da-x-ace/Authorship-Attribution> .
<https://github.com/fanyang88/Tic_Tac_Toe> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/arpitsardhana/ODR-on-local-LAN> <https://schema.org/description> "The aim of this program is to implement an On-Demand shortest-hop Routing (ODR) protocol for routing messages in networks of fixed but arbitrary and unknown connectivity through a client/server time application in which clients and servers communicate with each other across a network using PF_PACKET sockets and Unix domain datagram sockets. The implementation is based on (a simplified version of) the AODV algorithm"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/da-x-ace/multicast-tour-application> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://schema.org/SoftwareSourceCode> .
<https://github.com/da-x-ace/Reliable-UDP> <https://schema.org/identifier> "7928878"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/fanyang88> <https://schema.org/author> <https://github.com/fanyang88/practise> .
<https://github.com/fanyang88/ARP_protocol> <https://schema.org/identifier> "7361309"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/fanyang88/distributed-algorithm-implementation-maekawa-s-algorithm> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/fanyang88/face-tracking> <https://schema.org/codeRepository> <https://github.com/fanyang88/face-tracking> .
<https://github.com/fanyang88/distributed-algorithm_Agarwal-El-Abbadi> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q28865> .
<https://github.com/SOYJUN/FTP-implement-based-on-UDP> <https://schema.org/dateModified> "2019-03-26T17:11:10"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/vamsi44> <https://www.wikidata.org/wiki/Property:P3919> <https://github.com/vamsi44/On-Demand-Shortest-Hop-Routing> .
<https://github.com/SOYJUN/SBUshell> <https://schema.org/identifier> "33745516"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/SOYJUN/Application-with-raw-IP-sockets> <https://schema.org/name> "SOYJUN/Application-with-raw-IP-sockets"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/fanyang88/leetcode-in-js> <https://schema.org/name> "fanyang88/leetcode-in-js"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/da-x-ace/Misc> <https://schema.org/dateCreated> "2013-01-31T02:39:44"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
<https://github.com/da-x-ace/SuperComputing-HW3> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/da-x-ace> <https://www.wikidata.org/wiki/Property:P3919> <https://github.com/da-x-ace/On-Demand-Routing> .
<https://github.com/macosunity> <https://schema.org/name> "\u68A6\u60F3\u505A\u4E2A\u666E\u901A\u4EBA"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/sreeks1812> <https://schema.org/identifier> "5447379"^^<http://www.w3.org/2001/XMLSchema#int> .
<https://github.com/omsanket/-Tour-Application-using-C-language> <https://schema.org/programmingLanguage> <https://www.wikidata.org/wiki/Q15777> .
<https://github.com/fanyang88/leetcode_java> <https://schema.org/name> "fanyang88/leetcode_java"^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/sreeks1812/Adding-reliability-to-UDP> <https://schema.org/description> "Implemented a primitive file transfer protocol for UNIX platforms that sets up the exchange of packets between the client and the server using UDP in a secure way as in TCP. Introduced application-layer protocol data-transmission reliability, flow control and congestion control to the transfer operation using TCP-like ARQ sliding window mechanisms."^^<http://www.w3.org/2001/XMLSchema#string> .
<https://github.com/SOYJUN/SBU-OS-proj> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <https://www.wikidata.org/wiki/Property:P1324> .
<https://github.com/omsanket> <https://schema.org/identifier> "11070748"^^<http://www.w3.org/2001/XMLSchema#int> .
